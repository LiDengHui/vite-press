import{_ as i,c as a,o as t,a7 as e}from"./chunks/framework.DGe06YP7.js";const g=JSON.parse('{"title":"d.ts的作用","description":"","frontmatter":{},"headers":[],"relativePath":"语言/Typescript/d.ts的作用.md","filePath":"语言/Typescript/d.ts的作用.md","lastUpdated":1751247407000}'),n={name:"语言/Typescript/d.ts的作用.md"};function l(h,s,p,k,d,r){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="d-ts的作用" tabindex="-1">d.ts的作用 <a class="header-anchor" href="#d-ts的作用" aria-label="Permalink to “d.ts的作用”">​</a></h1><h2 id="背景简介" tabindex="-1">背景简介 <a class="header-anchor" href="#背景简介" aria-label="Permalink to “背景简介”">​</a></h2><p>在前端项目开发中，引入无内置 TypeScript 类型声明的第三方库时，TypeScript 编译器会报错。可在项目的 shims-vue.d.ts 中通过 declare 声明此模块来解决报错。同时引出几个问题： -为什么在 .shims-vue.d.ts 文件中写一个 declare 声明就能解决报错？</p><ul><li>.d.ts 文件明明显示引入，为什么就生效了？</li><li>任意 xxx.d.ts 文件声明为什么都能发挥作用吗？</li></ul><h2 id="d-ts-文件的作用" tabindex="-1">.d.ts 文件的作用 <a class="header-anchor" href="#d-ts-文件的作用" aria-label="Permalink to “.d.ts 文件的作用”">​</a></h2><p>.d.ts 文件是 TypeScript 世界中的“翻译器”，不负责运行代码，而是描述代码的结构、类型接口、模块，使 TypeScript 编译器正常进行类型检查、提示、自动补全等功能。具体作用如下：</p><h3 id="为-javascript-代码或第三方库补充类型" tabindex="-1">为 JavaScript 代码或第三方库补充类型 <a class="header-anchor" href="#为-javascript-代码或第三方库补充类型" aria-label="Permalink to “为 JavaScript 代码或第三方库补充类型”">​</a></h3><p>引入没有类型定义的库时，TS 编译器会报错，可写一个 .d.ts 文件手动声明其类型。例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// types/jquery.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="为非代码资源声明模块-如-svg、css、json-等" tabindex="-1">为非代码资源声明模块（如 SVG、CSS、JSON 等） <a class="header-anchor" href="#为非代码资源声明模块-如-svg、css、json-等" aria-label="Permalink to “为非代码资源声明模块（如 SVG、CSS、JSON 等）”">​</a></h3><p>在项目中引入非代码资源时，TypeScript 默认无法识别，需要 .d.ts 文件告知类型。例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// types/shims-svg.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;*.svg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="定义全局变量或类型" tabindex="-1">定义全局变量或类型 <a class="header-anchor" href="#定义全局变量或类型" aria-label="Permalink to “定义全局变量或类型”">​</a></h3><p>对于构建时注入的变量，可在 .d.ts 文件中声明，以便在任何文件中使用并获得类型提示。例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// types/global.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> VITE_APP_VERSION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="定义环境变量、全局命名空间等复杂类型结构" tabindex="-1">定义环境变量、全局命名空间等复杂类型结构 <a class="header-anchor" href="#定义环境变量、全局命名空间等复杂类型结构" aria-label="Permalink to “定义环境变量、全局命名空间等复杂类型结构”">​</a></h3><p>例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  myGlobalAPI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyLib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    debug</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="补充已有模块的类型信息-模块扩展" tabindex="-1">补充已有模块的类型信息（模块扩展） <a class="header-anchor" href="#补充已有模块的类型信息-模块扩展" aria-label="Permalink to “补充已有模块的类型信息（模块扩展）”">​</a></h3><p>可以给已有模块添加自定义类型，无需修改原始库代码。例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// types/vue-router.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RouteMeta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    auth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="为什么写一个-declare-就能解决报错" tabindex="-1">为什么写一个 declare 就能解决报错？ <a class="header-anchor" href="#为什么写一个-declare-就能解决报错" aria-label="Permalink to “为什么写一个 declare 就能解决报错？”">​</a></h2><p>TypeScript 是强类型语言，编译时会为每个变量、函数、模块、类型标识符“找到定义”。引入无类型声明第三方模块时，编译器会报错。当写上 <code>declare module &#39;xxx&#39;</code> 时，是手动告知 TypeScript 该模块存在，不用担忧类型问题，编译器不再报错，默认将其当作 any 类型处理，这是使用 .d.ts 的基础场景：模块声明补全。</p><h2 id="为什么-d-ts-文件不引入也能生效" tabindex="-1">为什么 .d.ts 文件不引入也能生效？ <a class="header-anchor" href="#为什么-d-ts-文件不引入也能生效" aria-label="Permalink to “为什么 .d.ts 文件不引入也能生效？”">​</a></h2><p>这与 TypeScript 的文件识别机制有关。TypeScript 编译项目时，先加载项目根目录下的 tsconfig.json，根据其中配置项决定包含、排除的文件，使用的类型库，以及模块路径的解析方式。.d.ts 文件能自动生效的情况如下：</p><h3 id="在-tsconfig-json-的-include-范围内" tabindex="-1">在 tsconfig.json 的 include 范围内 <a class="header-anchor" href="#在-tsconfig-json-的-include-范围内" aria-label="Permalink to “在 tsconfig.json 的 include 范围内”">​</a></h3><p>只要 .d.ts 文件路径在 include 的匹配范围内，TS 编译器就会自动加载它。例如：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;include&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;src&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>将 shims-vue.d.ts 放在 src/ 或 types/ 下，它就会自动生效。</p><h3 id="被编译器当作-全局声明-文件识别" tabindex="-1">被编译器当作“全局声明”文件识别 <a class="header-anchor" href="#被编译器当作-全局声明-文件识别" aria-label="Permalink to “被编译器当作“全局声明”文件识别”">​</a></h3><p>.d.ts 文件中若无 import/export，会被 TypeScript 当作“全局类型声明文件”，自动合并进全局作用域，文件内容对所有文件可见。例如：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// types/global.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __APP_VERSION__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>可在任意 .ts 文件中直接使用 <strong>APP_VERSION</strong>，无需引入。</p><h3 id="被放置在默认类型目录下-如-types" tabindex="-1">被放置在默认类型目录下（如 @types） <a class="header-anchor" href="#被放置在默认类型目录下-如-types" aria-label="Permalink to “被放置在默认类型目录下（如 @types）”">​</a></h3><p>TypeScript 默认会去 node_modules/@types 中找类型定义（社区维护的 DefinitelyTyped 类型库）。将声明文件放进此路径，可模拟 npm 包类型的形式存在。</p><h2 id="任意-xxx-d-ts-文件都能生效吗" tabindex="-1">任意 xxx.d.ts 文件都能生效吗？ <a class="header-anchor" href="#任意-xxx-d-ts-文件都能生效吗" aria-label="Permalink to “任意 xxx.d.ts 文件都能生效吗？”">​</a></h2><p>并非如此。只有在 tsconfig.json 中的 include 中被包含，编译器才会自动加载。但以下情况，即使在 include 中声明也不会被加载：</p><table tabindex="0"><thead><tr><th>失败原因</th><th>解释</th></tr></thead><tbody><tr><td>使用了模块语法（如 import/export）导致该文件不再是全局声明</td><td>编译器不会自动把它合并为全局作用域</td></tr><tr><td>语法错误</td><td>编译器会跳过整个文件</td></tr></tbody></table>`,38)]))}const o=i(n,[["render",l]]);export{g as __pageData,o as default};
