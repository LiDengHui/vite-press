import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.TNYQ6xSD.js";const i=JSON.parse(`{"title":"SSR","description":"","frontmatter":{},"headers":[],"relativePath":"工程化/SSR.md","filePath":"工程化/SSR.md","lastUpdated":1751264527000}`),a={name:`工程化/SSR.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="ssr" tabindex="-1">SSR <a class="header-anchor" href="#ssr" aria-label="Permalink to “SSR”">​</a></h1><p>SSR（Server-Side Rendering，服务端渲染）是一种在服务器端将网页内容渲染为完整 HTML 文档后发送至客户端的技术，与客户端渲染（CSR）形成对比。以下是其核心概念及与其他渲染方式的详细对比：</p><h2 id="🔍-一、ssr-的核心概念" tabindex="-1">🔍 一、SSR 的核心概念 <a class="header-anchor" href="#🔍-一、ssr-的核心概念" aria-label="Permalink to “🔍 一、SSR 的核心概念”">​</a></h2><ol><li><p><strong>工作原理</strong></p><ul><li>用户请求页面 → 服务器执行前端代码生成完整 HTML → 返回含数据的 HTML 给浏览器 → 浏览器直接渲染页面 → 后续通过 “水合”（Hydration）激活交互功能。</li><li>示例：使用 Node.js 的 Express 框架渲染 React 组件为 HTML 字符串。</li></ul></li><li><p><strong>核心目标</strong></p><ul><li><strong>提升首屏速度</strong>：用户直接看到内容，减少白屏时间。</li><li><strong>优化 SEO</strong>：搜索引擎爬虫可抓取完整的 HTML 内容。</li><li><strong>兼容性</strong>：支持禁用 JavaScript 的浏览器。</li></ul></li></ol><h2 id="⚖️-二、ssr-与其他渲染方式的对比" tabindex="-1">⚖️ 二、SSR 与其他渲染方式的对比 <a class="header-anchor" href="#⚖️-二、ssr-与其他渲染方式的对比" aria-label="Permalink to “⚖️ 二、SSR 与其他渲染方式的对比”">​</a></h2><h3 id="_1-ssr-vs-csr-客户端渲染" tabindex="-1">1. <strong>SSR vs. CSR（客户端渲染）</strong> <a class="header-anchor" href="#_1-ssr-vs-csr-客户端渲染" aria-label="Permalink to “1. SSR vs. CSR（客户端渲染）”">​</a></h3><table tabindex="0"><thead><tr><th><strong>对比维度</strong></th><th><strong>SSR</strong></th><th><strong>CSR</strong></th></tr></thead><tbody><tr><td><strong>首屏加载时间</strong></td><td>⭐️ 快（服务器返回完整 HTML）</td><td>慢（需下载 JS 后渲染）</td></tr><tr><td><strong>SEO 支持</strong></td><td>⭐️ 友好（内容直出）</td><td>需额外处理（如预渲染）</td></tr><tr><td><strong>服务器负载</strong></td><td>高（实时渲染）</td><td>低（仅提供静态文件）</td></tr><tr><td><strong>动态内容更新</strong></td><td>需重新请求服务器</td><td>⭐️ 灵活（客户端局部更新）</td></tr><tr><td><strong>适用场景</strong></td><td>新闻/电商首页（SEO+首屏速度敏感）</td><td>后台系统/Web App（交互性强）</td></tr></tbody></table><h3 id="_2-ssr-vs-ssg-静态站点生成" tabindex="-1">2. <strong>SSR vs. SSG（静态站点生成）</strong> <a class="header-anchor" href="#_2-ssr-vs-ssg-静态站点生成" aria-label="Permalink to “2. SSR vs. SSG（静态站点生成）”">​</a></h3><ul><li><strong>SSG</strong>：在构建时预生成静态 HTML，直接由 CDN 分发。 <ul><li>✅ <strong>优势</strong>：加载速度最快、服务器压力最小，适合内容不变的博客/官网。</li><li>❌ <strong>劣势</strong>：无法处理动态数据（如实时库存）。</li></ul></li><li><strong>SSR</strong>：每次请求实时生成 HTML，适合动态内容（如用户个性化页面）。</li></ul><h3 id="_3-ssr-vs-边缘渲染-edge-ssr" tabindex="-1">3. <strong>SSR vs. 边缘渲染（Edge SSR）</strong> <a class="header-anchor" href="#_3-ssr-vs-边缘渲染-edge-ssr" aria-label="Permalink to “3. SSR vs. 边缘渲染（Edge SSR）”">​</a></h3><ul><li><strong>边缘渲染</strong>：将 SSR 逻辑部署到 CDN 边缘节点（如 Cloudflare Workers），减少网络延迟。</li><li>适用场景：全球用户访问的高并发应用（如跨境电商）。</li></ul><h2 id="⚠️-三、ssr-的优缺点" tabindex="-1">⚠️ 三、SSR 的优缺点 <a class="header-anchor" href="#⚠️-三、ssr-的优缺点" aria-label="Permalink to “⚠️ 三、SSR 的优缺点”">​</a></h2><ul><li><strong>优点</strong>： <ul><li>首屏性能优化（尤其弱网络环境）；</li><li>内容一致性高（服务器统一处理数据）。</li></ul></li><li><strong>缺点</strong>： <ul><li>开发复杂度高（需处理同构、状态同步问题）；</li><li>服务器成本增加（高并发时 CPU 压力大）。</li></ul></li></ul><h2 id="🛠️-四、ssr-的适用场景与技术栈" tabindex="-1">🛠️ 四、SSR 的适用场景与技术栈 <a class="header-anchor" href="#🛠️-四、ssr-的适用场景与技术栈" aria-label="Permalink to “🛠️ 四、SSR 的适用场景与技术栈”">​</a></h2><ol><li><strong>典型场景</strong><ul><li>SEO 敏感型：企业官网、新闻平台；</li><li>首屏速度关键：电商首页、登录页。</li></ul></li><li><strong>技术框架</strong><ul><li>React：Next.js（支持 <code>getServerSideProps</code> 数据预取）；</li><li>Vue：Nuxt.js。</li></ul></li></ol><h2 id="💎-总结" tabindex="-1">💎 总结 <a class="header-anchor" href="#💎-总结" aria-label="Permalink to “💎 总结”">​</a></h2><p>SSR 的核心价值在于<strong>平衡性能与动态性</strong>，尤其适合内容驱动型站点。选择时需权衡：</p><ul><li><strong>选 SSR</strong>：首屏速度 + SEO 优先；</li><li><strong>选 CSR</strong>：交互复杂 + 低服务器成本；</li><li><strong>选 SSG</strong>：内容静态 + 极致性能。</li></ul><p>随着边缘计算和同构框架（如 Next.js）的成熟，SSR 正成为高性能 Web 应用的主流方案。</p>`,19)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};