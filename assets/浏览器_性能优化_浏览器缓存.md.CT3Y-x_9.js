import{_ as o,c as a,o as c,a7 as i}from"./chunks/framework.DDkSvsBP.js";const m=JSON.parse('{"title":"网络性能优化","description":"","frontmatter":{"title":"网络性能优化","date":"2019-08-02T09:22:41.000Z","tags":null},"headers":[],"relativePath":"浏览器/性能优化/浏览器缓存.md","filePath":"浏览器/性能优化/浏览器缓存.md","lastUpdated":1750817186000}'),l={name:"浏览器/性能优化/浏览器缓存.md"};function d(t,e,r,h,s,n){return c(),a("div",null,e[0]||(e[0]=[i('<h2 id="设计网络方向的主要有三个" tabindex="-1">设计网络方向的主要有三个： <a class="header-anchor" href="#设计网络方向的主要有三个" aria-label="Permalink to “设计网络方向的主要有三个：”">​</a></h2><ol><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求/响应</li></ol><h2 id="http-请求-响应" tabindex="-1">HTTP 请求/响应 <a class="header-anchor" href="#http-请求-响应" aria-label="Permalink to “HTTP 请求/响应”">​</a></h2><ol><li>减少网络请求</li><li>减少单次网络请求所花费的时间</li></ol><h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to “浏览器缓存”">​</a></h2><h3 id="memorycache" tabindex="-1">MemoryCache <a class="header-anchor" href="#memorycache" aria-label="Permalink to “MemoryCache”">​</a></h3><p>图片全部会放到内存中缓存， 大文件的js或css会放到硬盘内，小的也放到内存中</p><h3 id="serviceworkcache" tabindex="-1">ServiceWorkCache <a class="header-anchor" href="#serviceworkcache" aria-label="Permalink to “ServiceWorkCache”">​</a></h3><p>独立于浏览器主线程，不能操作DOM，可以实现离线缓存、消息推送、网络代理</p><h3 id="httpcache" tabindex="-1">HTTPCache <a class="header-anchor" href="#httpcache" aria-label="Permalink to “HTTPCache”">​</a></h3><p><img src="https://raw.githubusercontent.com/LiDengHui/images/master/img20190802094419.png" alt="20190802094419.png" data-zoomable="true" loading="lazy"></p><ol><li>强缓存</li></ol><p>利用http请求头中的<code>expires</code>和<code>Cache-Control</code>两个字段来控制。同时出现时<code>Cache-Control</code>优先级更高</p><p><code>Cache-Control</code>关键字理解</p><blockquote><p><code>no-cache</code>: 直接绕过浏览器缓存，直接请求服务器，响应字段如果有浏览器不缓存 <code>no-store</code>: 浏览器和服务器都不缓存 <code>no-transform</code>: 不要随意转换我发过来的东西 <code>only-if-cached</code>: 缓存中有就返回，没有就不返回 <code>max-age</code>: 用于请求头，超过年龄限制就返回新的 <code>max-stale</code>: 用于请求头，允许返回已经过期的资源，但有最大时间限制 <code>min-fresh</code>: 用于请求头，对即将过期的资源不返回 <code>public</code>: 用于响应头，允许客户端缓存数据，也能给别人使用，比如代理服务器可以缓存 <code>private</code>: 用于响应头，允许客户端缓存数据，不能给别人使用</p></blockquote><ol start="2"><li>协商缓存</li></ol><p>依赖<code>Last-Modified</code>,<code>If-Modified-Since</code>和<code>ETag</code>,<code>If-None-Match</code>来实现</p><blockquote><p><code>Last-Modified</code>: response返回表示资源的最后修改时间 <code>If-Modified-Since</code>: 资源在请求期间是否有修改,如果没有修改，则命中协商缓存，从缓存中拿数据，如果有修改，则返回新的<code>Last-Modified</code>，和服务器资源</p></blockquote><p>问题：</p><ul><li>周期性的重写资源，但是资源内容没有改动</li><li>修改的内容不重要</li><li><code>Last-Modified</code>时间太短无法精确</li></ul><blockquote><p><code>ETag</code>: 资源的唯一标示，随服务器返回 <code>If-None-Match</code>: 服务器比较<code>If-No-Match</code>和当前资源的<code>ETag</code>比较，如果一样则返回缓存中的，如果不一样，就返回新的<code>ETag</code>和服务器资源</p></blockquote><ol start="4"><li>HTTP 缓存决策</li></ol><p><img src="https://raw.githubusercontent.com/LiDengHui/images/master/img20190802111709.png" alt="20190802111709.png" data-zoomable="true" loading="lazy"></p><ul><li>资源内容是否复用，拒绝一切形式缓存</li><li>是否需要向服务器发起请求</li><li>是否可以被代理服务器缓存</li><li>是否有缓存时间</li></ul><ol start="5"><li>PushCache</li></ol><p>指服务器HTTP2在server push阶段的缓存</p><ul><li>Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li><li>只存在session使用期间</li><li>共享同一个HTTP2连接，可以共享同一个PushCache</li></ul>',27)]))}const u=o(l,[["render",d]]);export{m as __pageData,u as default};
