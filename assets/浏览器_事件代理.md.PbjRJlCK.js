import{_ as i,c as a,o as t,a7 as l}from"./chunks/framework.CegclTe-.js";const c=JSON.parse('{"title":"事件代理","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/事件代理.md","filePath":"浏览器/事件代理.md","lastUpdated":1751078101000}'),n={name:"浏览器/事件代理.md"};function e(h,s,p,k,r,d){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="事件代理" tabindex="-1">事件代理 <a class="header-anchor" href="#事件代理" aria-label="Permalink to “事件代理”">​</a></h1><h2 id="什么是事件代理" tabindex="-1">什么是事件代理 <a class="header-anchor" href="#什么是事件代理" aria-label="Permalink to “什么是事件代理”">​</a></h2><p>事件委托或事件代理: 根据具《js高级程序设计》一书来说就是利用事件冒泡, 指定一个事件处理程序,就可以管理某一类的所有事件.举个例子: dom需要事件处理程序,我们都会给他设置事件处理程序, but, 如果有在ul中全部100个li需要添加事件处理程序,其具有相同的点击事件,那么可以根据for来进行遍历, 也可以根据上层的ul来添加.在性能的角度来看,把ul建立事件会减少dom的交互次数,提高性能.</p><h2 id="事件代理的原理" tabindex="-1">事件代理的原理 <a class="header-anchor" href="#事件代理的原理" aria-label="Permalink to “事件代理的原理”">​</a></h2><p>事件委托是利用事件的冒泡原理来实现的,就是事件从最深的节点开始,然后逐步向上传播事件</p><p>举个例子: 页面上有这么一个节点树,</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>比如给最里面的a加一个click点击事件,那么这个事件就会一层一层的往外执行, 执行顺序</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>a &gt; li &gt; ul &gt; div</span></span></code></pre></div><p>有这样的一个机制,那么我们给最外面的div加点击事件,那么里面的ul,li,a做点击事件的时候,都会冒泡到最外层的div上,所以都会触发,这就是事件委托,委托他们父级代理</p>`,10)]))}const o=i(n,[["render",e]]);export{c as __pageData,o as default};
