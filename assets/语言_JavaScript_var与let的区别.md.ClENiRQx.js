import{_ as i,c as a,o as t,a7 as l}from"./chunks/framework.t6yJIVLk.js";const g=JSON.parse('{"title":"var与let的区别","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/var与let的区别.md","filePath":"语言/JavaScript/var与let的区别.md","lastUpdated":1751079736000}'),n={name:"语言/JavaScript/var与let的区别.md"};function e(h,s,k,p,r,d){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="var与let的区别" tabindex="-1">var与let的区别 <a class="header-anchor" href="#var与let的区别" aria-label="Permalink to “var与let的区别”">​</a></h1><p>在 JavaScript 中，<code>var</code> 和 <code>let</code> 都是用于声明变量，但它们之间存在几个<strong>关键区别</strong>，这些区别影响着变量的作用域、提升行为以及重复声明：</p><h2 id="🧠-1-作用域" tabindex="-1">🧠 1. 作用域 <a class="header-anchor" href="#🧠-1-作用域" aria-label="Permalink to “🧠 1. 作用域”">​</a></h2><ul><li><p><strong><code>var</code>：函数作用域</strong></p><ul><li>在函数内部声明的变量，在整个函数内部都有效。</li><li>在函数外部声明的变量，成为全局变量。</li><li><strong>不受块级作用域约束</strong>（如 <code>if</code>, <code>for</code>, <code>while</code> 等代码块）。在块内声明的 <code>var</code> 变量会&quot;泄漏&quot;到包含它的函数作用域或全局作用域中。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> exampleVar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量 x 的作用域是整个 exampleVar 函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 10 ✅，因为 x 在 if 块外依然可见</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong><code>let</code>：块级作用域</strong></p><ul><li>变量仅在声明它的代码块（<code>{}</code>）内有效（包括 <code>if</code>, <code>for</code>, <code>while</code>, <code>switch</code>, 以及单独的 <code>{}</code> 块）。</li><li>解决了 <code>var</code> 的变量泄漏问题，使变量生命周期更精确、更可预测。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> exampleLet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量 y 的作用域仅限于这个 if 块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 20 ✅</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(y); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ ReferenceError: y is not defined (y 在 if 块外不可见)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul><h2 id="📦-2-变量提升" tabindex="-1">📦 2. 变量提升 <a class="header-anchor" href="#📦-2-变量提升" aria-label="Permalink to “📦 2. 变量提升”">​</a></h2><ul><li><p><strong><code>var</code>：声明被提升，初始化不提升</strong></p><ul><li>变量的<strong>声明</strong>会被提升到其作用域（函数或全局）的顶部。</li><li>变量的<strong>初始化</strong>（赋值）留在原地。</li><li>在声明之前访问变量会得到 <code>undefined</code>。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 undefined ✅ (声明被提升，但值未初始化)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 5 ✅</span></span></code></pre></div></li><li><p><strong><code>let</code>：存在&quot;暂时性死区&quot;</strong></p><ul><li>声明也会被提升到其<strong>块级作用域</strong>的顶部。</li><li>但在声明语句执行之前，变量处于&quot;暂时性死区&quot;。在 TDZ 中访问变量会导致 <strong><code>ReferenceError</code></strong>。</li><li>强制你在使用前声明变量，避免意外行为。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ ReferenceError: Cannot access &#39;b&#39; before initialization (处于 TDZ)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 10 ✅</span></span></code></pre></div></li></ul><h2 id="🔁-3-重复声明" tabindex="-1">🔁 3. 重复声明 <a class="header-anchor" href="#🔁-3-重复声明" aria-label="Permalink to “🔁 3. 重复声明”">​</a></h2><ul><li><p><strong><code>var</code>：允许在相同作用域内重复声明</strong></p><ul><li>不会报错，后面的声明会覆盖前面的（可能导致难以追踪的错误）。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 允许重复声明</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 2</span></span></code></pre></div></li><li><p><strong><code>let</code>：不允许在相同作用域内重复声明</strong></p><ul><li>在同一个块级作用域内重复声明同一个变量名会导致 <strong><code>SyntaxError</code></strong>。</li><li>有助于防止命名冲突和意外覆盖。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ SyntaxError: Identifier &#39;d&#39; has already been declared</span></span></code></pre></div></li></ul><h2 id="🧩-4-全局作用域下的行为" tabindex="-1">🧩 4. 全局作用域下的行为 <a class="header-anchor" href="#🧩-4-全局作用域下的行为" aria-label="Permalink to “🧩 4. 全局作用域下的行为”">​</a></h2><ul><li><p><strong><code>var</code>：在全局作用域声明时，会成为全局对象（浏览器中是 <code>window</code>）的属性。</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;I&#39;m global&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.globalVar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在浏览器中输出 &quot;I&#39;m global&quot; ✅</span></span></code></pre></div></li><li><p><strong><code>let</code>：在全局作用域声明时，不会成为全局对象（<code>window</code>）的属性。</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalLet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;I&#39;m also global, but not attached&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.globalLet); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在浏览器中输出 undefined ✅</span></span></code></pre></div></li></ul><h2 id="📌-总结与最佳实践" tabindex="-1">📌 总结与最佳实践 <a class="header-anchor" href="#📌-总结与最佳实践" aria-label="Permalink to “📌 总结与最佳实践”">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th><code>var</code></th><th><code>let</code></th></tr></thead><tbody><tr><td><strong>作用域</strong></td><td>函数作用域</td><td><strong>块级作用域</strong> ✅</td></tr><tr><td><strong>提升</strong></td><td>声明提升，初始化不提升</td><td>提升但存在<strong>TDZ</strong> ✅</td></tr><tr><td><strong>重复声明</strong></td><td>允许 ✅</td><td><strong>禁止</strong> ✅ (SyntaxError)</td></tr><tr><td><strong>全局属性</strong></td><td>成为<code>window</code>属性</td><td><strong>不成为<code>window</code>属性</strong> ✅</td></tr><tr><td><strong>现代实践</strong></td><td>⚠️ 遗留，避免使用</td><td>✅ 推荐用于可变量声明</td></tr></tbody></table><ul><li><strong>优先使用 <code>let</code> (和 <code>const</code>)：</strong> <code>let</code> 的块级作用域和禁止重复声明特性显著提高了代码的可读性、可维护性和可靠性，避免了 <code>var</code> 常见的陷阱（如变量泄漏出循环、意外覆盖）。</li><li><strong>理解 <code>var</code>：</strong> 主要用于理解旧代码或特定历史背景，在新项目中应避免使用。</li><li><strong>使用 <code>const</code>：</strong> 对于值不会改变的变量，应优先使用 <code>const</code> 声明常量，这能提供额外的安全保障并表明意图。</li></ul><p>简单来说：<strong><code>let</code> 解决了 <code>var</code> 的主要设计缺陷，是现代 JavaScript 中声明变量的标准方式。</strong> 请尽量使用 <code>let</code> 和 <code>const</code> 替代 <code>var</code>。</p>`,14)]))}const c=i(n,[["render",e]]);export{g as __pageData,c as default};
