import{_ as d,c as e,o as r,a7 as o}from"./chunks/framework.BQO8qXET.js";const P=JSON.parse('{"title":"Promise 相关的函数","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/Promise/Promise相关的函数.md","filePath":"语言/JavaScript/Promise/Promise相关的函数.md","lastUpdated":1750738239000}'),s={name:"语言/JavaScript/Promise/Promise相关的函数.md"};function i(a,t,c,n,l,m){return r(),e("div",null,t[0]||(t[0]=[o('<h1 id="promise-相关的函数" tabindex="-1">Promise 相关的函数 <a class="header-anchor" href="#promise-相关的函数" aria-label="Permalink to “Promise 相关的函数”">​</a></h1><p>以下是整理后的 Promise 相关方法 Markdown 表格，包含传统方法和新增方法：</p><h3 id="📊-promise-核心方法总览" tabindex="-1">📊 Promise 核心方法总览 <a class="header-anchor" href="#📊-promise-核心方法总览" aria-label="Permalink to “📊 Promise 核心方法总览”">​</a></h3><table tabindex="0"><thead><tr><th><strong>方法名</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th><th><strong>参数</strong></th><th><strong>返回值</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>基础方法</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>new Promise(executor)</code></td><td>构造器</td><td>创建 Promise 对象</td><td><code>executor(resolve, reject)</code> 函数</td><td>Promise 实例</td><td>封装异步操作</td></tr><tr><td><code>.then(onFulfilled, onRejected?)</code></td><td>实例方法</td><td>处理成功状态</td><td><code>onFulfilled</code>: 成功回调<br><code>onRejected</code>: 可选失败回调</td><td>新 Promise 对象</td><td>异步流程链式调用</td></tr><tr><td><code>.catch(onRejected)</code></td><td>实例方法</td><td>处理失败状态</td><td><code>onRejected</code>: 失败回调</td><td>新 Promise 对象</td><td>错误捕获</td></tr><tr><td><code>.finally(onFinally)</code></td><td>实例方法</td><td>无论成功/失败都执行</td><td><code>onFinally</code>: 无参数回调</td><td>新 Promise 对象</td><td>资源清理/日志记录</td></tr><tr><td><strong>静态方法</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>Promise.resolve(value)</code></td><td>静态方法</td><td>创建已完成的 Promise</td><td>任何类型值</td><td>已完成的 Promise</td><td>同步值转 Promise</td></tr><tr><td><code>Promise.reject(reason)</code></td><td>静态方法</td><td>创建已拒绝的 Promise</td><td>错误原因</td><td>已拒绝的 Promise</td><td>快速返回错误</td></tr><tr><td><code>Promise.all(iterable)</code></td><td>静态方法</td><td>所有 Promise 成功时返回结果数组</td><td>Promise 可迭代对象</td><td>新 Promise 对象</td><td>并行多个异步操作</td></tr><tr><td><code>Promise.allSettled(iterable)</code></td><td>静态方法</td><td>所有 Promise 完成后返回状态结果数组</td><td>Promise 可迭代对象</td><td>新 Promise 对象</td><td>需要所有操作的最终状态</td></tr><tr><td><code>Promise.race(iterable)</code></td><td>静态方法</td><td>返回第一个完成的 Promise</td><td>Promise 可迭代对象</td><td>新 Promise 对象</td><td>超时控制/竞速场景</td></tr><tr><td><code>Promise.any(iterable)</code></td><td>静态方法</td><td>返回第一个成功的 Promise</td><td>Promise 可迭代对象</td><td>新 Promise 对象</td><td>获取最快成功结果</td></tr><tr><td><strong>新增方法 (ES2024+)</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>Promise.try(func)</code></td><td>静态方法</td><td>统一包装同步/异步函数，自动捕获错误</td><td><code>func</code>: 要执行的函数</td><td>新 Promise 对象</td><td>混合任务链/错误安全封装</td></tr><tr><td><code>Promise.withResolvers()</code></td><td>静态方法</td><td>返回 <code>{ promise, resolve, reject }</code> 对象</td><td>无</td><td>解构对象</td><td>事件驱动/外部控制状态</td></tr></tbody></table><hr><h3 id="🔍-方法特性对比表" tabindex="-1">🔍 方法特性对比表 <a class="header-anchor" href="#🔍-方法特性对比表" aria-label="Permalink to “🔍 方法特性对比表”">​</a></h3><table tabindex="0"><thead><tr><th><strong>特性</strong></th><th><code>Promise.all()</code></th><th><code>Promise.any()</code></th><th><code>Promise.allSettled()</code></th><th><code>Promise.race()</code></th></tr></thead><tbody><tr><td><strong>成功条件</strong></td><td>全部成功</td><td>至少一个成功</td><td>全部完成</td><td>第一个完成</td></tr><tr><td><strong>失败条件</strong></td><td>任一失败</td><td>全部失败</td><td>永不失败</td><td>第一个失败</td></tr><tr><td><strong>结果类型</strong></td><td>值数组</td><td>单个值</td><td>状态对象数组</td><td>单个值/错误</td></tr><tr><td><strong>错误处理</strong></td><td>立即拒绝</td><td>AggregateError</td><td>包含错误状态</td><td>立即拒绝</td></tr><tr><td><strong>适用场景</strong></td><td>强依赖并行操作</td><td>获取最快成功</td><td>收集所有操作状态</td><td>竞速/超时控制</td></tr></tbody></table><hr><h3 id="⚡-新增方法详解" tabindex="-1">⚡ 新增方法详解 <a class="header-anchor" href="#⚡-新增方法详解" aria-label="Permalink to “⚡ 新增方法详解”">​</a></h3><table tabindex="0"><thead><tr><th><strong>方法</strong></th><th><strong>核心优势</strong></th><th><strong>示例场景</strong></th></tr></thead><tbody><tr><td><code>Promise.try()</code></td><td>• 统一同步/异步错误处理<br>• 自动捕获同步异常</td><td><code>Promise.try(() =&gt; JSON.parse(input)).catch(handleError)</code></td></tr><tr><td><code>Promise.withResolvers()</code></td><td>• 外部控制 Promise 状态<br>• 避免变量污染</td><td><code>const {promise, resolve} = Promise.withResolvers()&lt;br&gt;event.on(&#39;done&#39;, resolve)</code></td></tr></tbody></table><hr><h3 id="💎-使用建议" tabindex="-1">💎 使用建议 <a class="header-anchor" href="#💎-使用建议" aria-label="Permalink to “💎 使用建议”">​</a></h3><ol><li><strong>错误处理</strong>：始终使用 <code>.catch()</code> 或 <code>try/catch</code>（async/await）处理拒绝状态</li><li><strong>资源清理</strong>：使用 <code>.finally()</code> 确保资源释放</li><li><strong>现代特性</strong>：在支持环境（Node.js 22+ / Chrome 122+）优先使用 <code>Promise.try()</code> 和 <code>Promise.withResolvers()</code></li><li><strong>并发控制</strong>： <ul><li>全成功：<code>Promise.all()</code></li><li>需所有结果：<code>Promise.allSettled()</code></li><li>最快成功：<code>Promise.any()</code></li></ul></li></ol><blockquote><p>完整规范参考：<a href="https://tc39.es/ecma262/#sec-promise-objects" target="_blank" rel="noreferrer">ECMAScript Promise</a></p></blockquote>',14)]))}const g=d(s,[["render",i]]);export{P as __pageData,g as default};
