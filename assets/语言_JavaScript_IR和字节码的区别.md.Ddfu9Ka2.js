import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.TNYQ6xSD.js";const i=JSON.parse(`{"title":"IR和字节码的区别","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/IR和字节码的区别.md","filePath":"语言/JavaScript/IR和字节码的区别.md","lastUpdated":1751078101000}`),a={name:`语言/JavaScript/IR和字节码的区别.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="ir和字节码的区别" tabindex="-1">IR和字节码的区别 <a class="header-anchor" href="#ir和字节码的区别" aria-label="Permalink to “IR和字节码的区别”">​</a></h1><p><strong>IR（Intermediate Representation，中间表示）确实有点像汇编语言</strong>，但它们的目的和抽象层次不同。下面我们来深入比较一下：</p><h2 id="✅-ir-和汇编语言的相似点" tabindex="-1">✅ IR 和汇编语言的相似点 <a class="header-anchor" href="#✅-ir-和汇编语言的相似点" aria-label="Permalink to “✅ IR 和汇编语言的相似点”">​</a></h2><table tabindex="0"><thead><tr><th>相似点</th><th>说明</th></tr></thead><tbody><tr><td>✅ 都是中间层语言</td><td>都处在高级语言和机器码之间</td></tr><tr><td>✅ 都使用寄存器/栈的概念</td><td>表达计算逻辑和数据流</td></tr><tr><td>✅ 结构通常是线性的指令序列</td><td>指令风格，如 <code>load</code>, <code>store</code>, <code>add</code>, <code>jmp</code> 等</td></tr><tr><td>✅ 都适合代码优化和分析</td><td>编译器或 JIT 可对其做很多优化处理</td></tr></tbody></table><h2 id="❌-它们的本质区别" tabindex="-1">❌ 它们的本质区别 <a class="header-anchor" href="#❌-它们的本质区别" aria-label="Permalink to “❌ 它们的本质区别”">​</a></h2><table tabindex="0"><thead><tr><th>项目</th><th>IR</th><th>汇编语言</th></tr></thead><tbody><tr><td>属于谁</td><td>编译器（如 LLVM IR、V8 Bytecode）</td><td>特定 CPU 架构（如 x86、ARM）</td></tr><tr><td>平台依赖性</td><td><strong>跨平台</strong></td><td><strong>平台相关</strong>（依赖 CPU 架构）</td></tr><tr><td>抽象层次</td><td>较高抽象</td><td>非常接近机器码</td></tr><tr><td>可移植性</td><td>✅ 高</td><td>❌ 低</td></tr><tr><td>是否可执行</td><td>❌ 需要进一步编译</td><td>✅ 可被汇编器翻译为机器码</td></tr></tbody></table><h2 id="🧠-举个对比例子-加法" tabindex="-1">🧠 举个对比例子（加法） <a class="header-anchor" href="#🧠-举个对比例子-加法" aria-label="Permalink to “🧠 举个对比例子（加法）”">​</a></h2><h3 id="llvm-ir-中间表示" tabindex="-1">LLVM IR（中间表示）： <a class="header-anchor" href="#llvm-ir-中间表示" aria-label="Permalink to “LLVM IR（中间表示）：”">​</a></h3><div class="language-llvm"><button title="Copy Code" class="copy"></button><span class="lang">llvm</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">%1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> i32</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> %a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">%b</span></span></code></pre></div><h3 id="x86-汇编" tabindex="-1">x86 汇编： <a class="header-anchor" href="#x86-汇编" aria-label="Permalink to “x86 汇编：”">​</a></h3><div class="language-asm"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> eax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span></span></code></pre></div><ul><li>LLVM IR 不关心是哪个 CPU，它只表达“加法”语义；</li><li>汇编则是具体告诉 x86 CPU 如何执行“加法”。</li></ul><h2 id="🔥-不同类型的-ir-示例" tabindex="-1">🔥 不同类型的 IR 示例 <a class="header-anchor" href="#🔥-不同类型的-ir-示例" aria-label="Permalink to “🔥 不同类型的 IR 示例”">​</a></h2><table tabindex="0"><thead><tr><th>IR 类型</th><th>示例</th><th>用途</th></tr></thead><tbody><tr><td>高层 IR</td><td>SSA、AST</td><td>优化语义、类型分析</td></tr><tr><td>中层 IR</td><td>LLVM IR</td><td>编译器优化、目标无关</td></tr><tr><td>低层 IR</td><td>字节码、V8 Bytecode</td><td>解释执行、接近机器但仍跨平台</td></tr><tr><td>极低层 IR</td><td>汇编语言</td><td>平台相关，映射到机器码</td></tr></tbody></table><h2 id="✅-总结一句话" tabindex="-1">✅ 总结一句话： <a class="header-anchor" href="#✅-总结一句话" aria-label="Permalink to “✅ 总结一句话：”">​</a></h2><blockquote><p><strong>IR 像是一种“跨平台汇编”，结构像汇编但不面向具体硬件，用于编译器中间阶段优化或解释执行；而汇编语言是面向具体 CPU 的低级语言，直接控制硬件执行。</strong></p></blockquote><p>如果你感兴趣，我可以展示某段 C/Rust 代码对应的 LLVM IR 和汇编代码的对比。要看吗？</p>`,17)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};