import{_ as e,c as l,o as i,a3 as r}from"./chunks/framework.D-BI-jj5.js";const t="/vite-press/assets/2020-11-15-12-30-20.CH_UiItv.png",T="/vite-press/assets/2020-11-15-12-30-43.BpYo7ind.png",p="/vite-press/assets/2020-11-15-12-31-02.cTXZlNX0.png",H=JSON.parse('{"title":"HTTP2.0特征","description":"","frontmatter":{"title":"HTTP2.0特征","tags":["HTTP"],"categories":["技术文档","前端","HTTP"],"date":"2020-11-13T22:27:41.000Z"},"headers":[],"relativePath":"浏览器/HTTP2.0.md","filePath":"浏览器/HTTP2.0.md","lastUpdated":1749107541000}'),s={name:"浏览器/HTTP2.0.md"};function n(P,a,o,h,d,c){return i(),l("div",null,a[0]||(a[0]=[r('<h1 id="多路复用" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用" aria-label="Permalink to “多路复用”">​</a></h1><p>多路复用代替原来的序列和阻塞机制, 所有就是请求的都是通过一个TCP连接并发完成. 同时也很好的解决了浏览器限制同一个域名下的请求数量的问题</p><p>在HTTP/2中,有了二进制分帧之后, HTTP/2不再依赖TCP链接去实现多流并行了,在HTTP/2中:</p><ol><li>同域名下所有的通信都在单个链接上完成, 同个域名只需要占用一个TCP链接,使用一个连接并行发送多个请求和响应</li><li>单个连接可以承载任意数量的双向数据流,单个连接上可以并行交错的请求和响应,之间互不干扰</li><li>数据流以消息的形式发送, 而消息又由一个或多帧组成, 多个帧之间可以乱序发送, 因为根据帧首部的流标识可以重新组装, 每个请求都可以带一个31bit的优先值, 0标示最高优先级, 数值越大优先级越低</li></ol><h1 id="帧和流" tabindex="-1">帧和流 <a class="header-anchor" href="#帧和流" aria-label="Permalink to “帧和流”">​</a></h1><h2 id="帧-frame" tabindex="-1">帧(frame) <a class="header-anchor" href="#帧-frame" aria-label="Permalink to “帧(frame)”">​</a></h2><p>HTTP/2 中数据传输的最小单位, 因此帧不仅要细分表达 HTTP/1.x中的各个部分,也优化了HTTP/1.x表达不好的地方, 同时还增加了HTTP/1.x表达不了的方式</p><p>每一帧包含几个字段, 有 length、type、flags、stream、identifier、frame playload等, 其中 type 代表帧的类型</p><p>在HTTP/2的标准中定义了10种不同的类型</p><ol><li>HEADERS frame</li><li>DATA frame</li><li>PRIOPRITY (设置流的优先级)</li><li>RST_STREAM (终止流)</li><li>SETTINGS(设置此连接的参数)</li><li>PUSH_PROMISE (服务器推送)</li><li>PING(测量RTT)</li><li>GOAWAY(终止连接)</li><li>WINDOW——UPDATE(流量控制)</li><li>CONTINUATION (继续传输头部数据)</li></ol><p>在HTTP2.0中, 它把数据报的两达部分分成了Header frame 和 data frame 也就是 头部帧和数据体帧</p><h2 id="流-stream" tabindex="-1">流(stream) <a class="header-anchor" href="#流-stream" aria-label="Permalink to “流(stream)”">​</a></h2><p>流: 存在于连接中的一个虚拟通道.流可以承载双向消息, 每个流都有一个唯一的整数ID. HTP/2 长连接中的数据报不是按照请求-响应顺序发送的, 一个完整的请求或响应(称一个数据流stream, 每个数据流都有一个独一无二的编号)可能会分成非连续多次发送.</p><p>特点:</p><ol><li>双向性: 同一个流内,可同时发送和接受数据</li><li>有序性: 流中被传输的数据就是二进制帧. 帧在流上的被发送于被接收都是按照顺序进行的</li><li>并行性: 流中的二进制帧 都是被并行传输的,无需按顺序等待</li><li>流的创建: 流可以被客户端和服务器单方面建立, 使用、共享</li><li>流的关闭: 流也可以被任意一方关闭</li><li>HEADERS 帧在DATE 帧前面</li><li>流的ID都是奇数,说明是由客户端发起的,服务端发起的就是偶数</li></ol><h1 id="发展历程" tabindex="-1">发展历程 <a class="header-anchor" href="#发展历程" aria-label="Permalink to “发展历程”">​</a></h1><p>从 HTTP/0.9 到 Http/2 要发送多个请求, 从多个TCP连接 =&gt; Keep-alive =&gt; 管道化 =&gt; 多路复用 不断的减少多次创建 TCP 等等带来的性能损耗</p><h2 id="多个tcp连接" tabindex="-1">多个TCP连接 <a class="header-anchor" href="#多个tcp连接" aria-label="Permalink to “多个TCP连接”">​</a></h2><p>在最早的时候没有 keep-alive 只能创建多个TCP连接来做多次请求. 一次请求完成就会关闭本次的TCP 连接, 下个请求又要重新建立新的TCP连接传输完成数据再次关闭,造成很大的性能消耗</p><h2 id="keep-alive" tabindex="-1">Keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to “Keep-alive”">​</a></h2><p>Keep-alive 解决的核心问题是: 一定时间内,同一域名多次请求数据,只建立一次HTTP请求,其他请求可复用每一次建立的连接通道,以达到提高请求效率的问题, 这里面所说的一定时间是可以配置的,不管你用的是Apache还是nginx</p><p>以往,浏览器判断响应数据是否接收完毕,是看连接是否关闭.在使用持久连接后,就不能这样了,这就要求服务器对持久连接的响应头部一定要返回content-length标识body的长度,供浏览器判断界限.有时,content-length的方法并不是太准确,也可以使用transfer-encoding:chunked头部发送一串一串的数据,最后长度为0的chunked标示结束</p><p>多次http请求效果如下图所示</p><p><img src="'+t+'" alt="" loading="lazy"></p><p>Keep-alive 还是存在如下问题:</p><ol><li>串行的文件传输</li><li>同域并行请求限制带来的阻塞(6~8)个</li></ol><h2 id="管线化" tabindex="-1">管线化 <a class="header-anchor" href="#管线化" aria-label="Permalink to “管线化”">​</a></h2><p>HTTP管线化可以克服同域并行请求限制带来的阻塞,它是建立在持久连接上的,是把所有的请求一并发给服务器, 但是服务器需要按照顺序一个一个的响应,而不是等到一个响应回来才能发下一个请求,这样就节省了很多请求到服务器的时间,不过HTTP管线化依旧有阻塞的问题,若上一响应迟迟不回,后面的响应都会被阻塞到</p><p><img src="'+T+'" alt="" loading="lazy"></p><h2 id="多路复用-1" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用-1" aria-label="Permalink to “多路复用”">​</a></h2><p>多路复用代替原来的序列和阻塞机制.所有就是请求的都是通过一个TCP连接并发完成.因为在多路复用之前所有的传输是基于基础文本的,在多路复用中是基于二进制数据帧的,传输、消息、流,所以可以做到乱序的传输.多路复用对同一域名下所有请求都是基于流,所以不存在同域并行的阻塞.多次请求如下图:</p><p><img src="'+p+'" alt="" loading="lazy"></p><p>HTTP/1.x默认开启持久连接,在一个TCP连接上可以传送多个HTTP请求和响应,减少了建立和关闭连接的消耗和延迟</p><p>HTTP/2.0 支持多路复用,这是HTTP/1.x持久连接的升级版, 多路复用,就是在一个TCP 连接中可以存在多条流, 也就是可以发送多个请求,服务端则可以通过帧中的标识知道该帧属于哪个流(即请求), 通过重新排序还原请求, 多路复用允许并发多个请求,每个请求及该请求的响应不需要等待其他的请求或响应,避免了线头阻塞问题.这样某个请求任务耗时严重,不会影响其他连接的正常执行, 极大的提高传输性能</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><p>在 HTTP/2 中, 有两个非常重要的概念,分别是帧(frame)和流(stream).</p><p>帧代表着最小的数据单位,每个帧会标识出该帧属于哪个流, 流也就是多个帧组成的数据流</p><p>HTTP2 采用二进制数据帧传输, 取代了HTTP1.x的文本格式,二进制格式解析更高效.</p><p>多路复用代替了 HTTP1.x的序列和阻塞机制没,所有的相同域名请求都通过同一个TCP连接并发完成.同一TCP中可以发送多个请求,对端可以通过帧中的标识知道属于哪个请求,通过这个技术,可以避免HTTP旧版本中的队头阻塞问题,极大的提高传输性能.</p>',39)]))}const f=e(s,[["render",n]]);export{H as __pageData,f as default};
