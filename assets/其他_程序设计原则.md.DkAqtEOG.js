import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.TNYQ6xSD.js";const i=JSON.parse(`{"title":"程序设计原则","description":"","frontmatter":{},"headers":[],"relativePath":"其他/程序设计原则.md","filePath":"其他/程序设计原则.md","lastUpdated":1752915655000}`),a={name:`其他/程序设计原则.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="程序设计原则" tabindex="-1">程序设计原则 <a class="header-anchor" href="#程序设计原则" aria-label="Permalink to “程序设计原则”">​</a></h1><p>好的，程序设计原则是编写高质量、可维护、可扩展软件的基础。它们指导我们如何组织代码（类、包/模块）以及它们之间的关系。下面分别介绍类级别和包级别的主要设计原则：</p><h2 id="一、类级别的设计原则-solid-其他关键原则" tabindex="-1">一、类级别的设计原则 (SOLID + 其他关键原则) <a class="header-anchor" href="#一、类级别的设计原则-solid-其他关键原则" aria-label="Permalink to “一、类级别的设计原则 (SOLID + 其他关键原则)”">​</a></h2><p>这些原则主要关注单个类内部的职责以及类与类之间如何交互。</p><ol><li><p><strong>单一职责原则（SRP - Single Responsibility Principle）</strong></p><ul><li><strong>核心思想：</strong> 一个类应该只有一个引起它变化的原因。换句话说，一个类应该只负责一项职责。</li><li><strong>为什么重要：</strong> 职责越单一，类就越内聚，越容易被理解、修改和测试。修改一个职责不会意外影响其他不相关的功能。</li><li><strong>违反示例：</strong> 一个<code>Order</code>类既负责处理订单数据（如计算总额），又负责将订单保存到数据库，还负责发送订单确认邮件。</li></ul></li><li><p><strong>开闭原则 (OCP - Open/Close Principle)</strong></p><ul><li><strong>核心思想：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</li><li><strong>为什么重要：</strong> 允许在不修改现有代码的情况下添加新功能，提高了系统的稳定性和可扩展性，降低了引入新错误的风险。</li><li><strong>如何实现：</strong> 通常通过抽象（接口、抽象类）和依赖注入来实现。新功能通过实现新的具体类来添加，而不是修改已有的类。</li><li><strong>违反示例：</strong> 添加一个新的支付方式（如PayPal）需要修改现有的<code>PaymentProcessor</code>类的代码。</li></ul></li><li><p><strong>里氏替换原则 (LSP - Liskov Substitution Principle)</strong></p><ul><li><strong>核心思想：</strong> 子类型必须能够替换掉它们的基类型，而程序的行为不会发生改变。即任何基类出现的地方，子类都可以出现。</li><li><strong>为什么重要：</strong> 保证继承关系的正确性，确保多态行为符合预期。子类不应该破坏父类的契约（前置条件、后置条件、不变式）。</li><li><strong>违反示例：</strong> 正方形类继承自长方形类。长方形有<code>SetWidth</code>和<code>SetHeight</code>方法可以独立设置。但正方形要求宽高相等，覆盖这些方法强制宽高一致。当一段期望独立设置宽高的代码（适用于长方形）接收到一个正方形对象时，行为会出错（违反了长方形的契约）。</li></ul></li><li><p><strong>接口隔离原则 (ISP - Interface Segregation Principle)</strong></p><ul><li><strong>核心思想：</strong> 客户端不应该被迫依赖于它们不使用的接口。多个特定功能的接口比一个庞大臃肿的总接口要好。</li><li><strong>为什么重要：</strong> 避免客户端依赖不需要的方法，减少耦合，提高系统的灵活性和可维护性。防止接口污染。</li><li><strong>违反示例：</strong> 一个庞大的<code>Worker</code>接口包含了<code>Work</code>, <code>Eat</code>, <code>Sleep</code>方法。<code>Robot</code>类实现了<code>Worker</code>，但它不需要<code>Eat</code>和<code>Sleep</code>，被迫提供了空实现或抛出异常。</li></ul></li><li><p><strong>依赖倒置原则 (DIP - Dependency Inversion Principle)</strong></p><ul><li><strong>核心思想：</strong><ul><li>高层模块不应该依赖于低层模块。二者都应该依赖于抽象。</li><li>抽象不应该依赖于细节。细节应该依赖于抽象。</li></ul></li><li><strong>为什么重要：</strong> 解耦高层业务逻辑与底层实现细节（如数据库访问、网络通信）。提高系统的灵活性、可测试性（更容易Mock）和可维护性。</li><li><strong>如何实现：</strong> 高层模块通过接口（抽象）定义它需要的服务，低层模块实现这些接口。依赖关系通过构造函数、Setter方法或依赖注入容器注入。</li><li><strong>违反示例：</strong> <code>ReportGenerator</code>类直接实例化并调用<code>MySQLDatabase</code>类的具体方法。</li></ul></li><li><p><strong>迪米特法则 (Law of Demeter, The Least Knowledge Principle)</strong></p><ul><li><strong>核心思想：</strong> 一个对象应该对其他对象有最少的了解。只与你的“直接朋友”交谈，不要跟“陌生人”说话。</li><li><strong>核心规则：</strong><ul><li>只调用自身的方法。</li><li>只调用传入参数的方法。</li><li>只调用自身创建的对象的方法。</li><li>只调用自身持有的成员对象的方法。</li></ul></li><li><strong>为什么重要：</strong> 降低类之间的耦合度，提高模块化程度。一个类的修改不会轻易传播到大量其他类。</li><li><strong>违反示例：</strong> <code>Customer</code>对象通过<code>Order</code>对象拿到<code>Item</code>对象，再直接调用<code>Item.GetPrice()</code>。<code>Customer</code>应该只与<code>Order</code>交互，由<code>Order</code>提供计算总价等方法（<code>Order.GetTotalPrice()</code>），<code>Order</code>内部再与<code>Item</code>交互。</li></ul></li><li><p><strong>组合优于继承原则（Composition Over Inheritance Principle）</strong></p><ul><li><strong>核心思想：</strong> 在代码复用时，优先考虑使用对象组合（has-a关系），而不是类继承（is-a关系）。</li><li><strong>为什么重要：</strong> 继承在编译时就固定了关系，可能导致脆弱的基类问题（父类修改影响所有子类），并且限制了灵活性。组合在运行时建立关系，更灵活，更容易改变行为（通过替换组件），更符合松耦合原则。</li><li><strong>何时用继承：</strong> 当两个类之间确实是严格的“是一种”关系，并且子类确实是父类的特化，且需要利用多态时。</li><li><strong>示例：</strong> 给一个<code>Car</code>类添加日志功能，应通过组合一个<code>Logger</code>对象（<code>Car has a Logger</code>），而不是创建一个<code>LoggableCar</code>父类。</li></ul></li></ol><h2 id="二、包-模块级别的设计原则-rep-ccp-crp-adp-sdp-sap" tabindex="-1">二、包/模块级别的设计原则 (REP, CCP, CRP, ADP, SDP, SAP) <a class="header-anchor" href="#二、包-模块级别的设计原则-rep-ccp-crp-adp-sdp-sap" aria-label="Permalink to “二、包/模块级别的设计原则 (REP, CCP, CRP, ADP, SDP, SAP)”">​</a></h2><p>这些原则（主要源自Robert C. Martin的《敏捷软件开发：原则、模式与实践》）关注如何将相关的类组织成包（Java）/模块（如Python, ES6, .NET）/命名空间（C++），以及包与包之间应该如何耦合。</p><ol><li><p><strong>重用发布等价原则(Reuse-Release Equivalence Principle - REP)</strong></p><ul><li><strong>核心思想：</strong> 重用的粒度就是发布的粒度。一个包（模块）中的所有类应该是内聚的、可作为一个整体单元被重用的。它们应该属于同一个重用范畴。</li><li><strong>为什么重要：</strong> 确保包是可独立发布和版本控制的单元。包内的类应该是为了共同的重用目的而聚集在一起的。</li><li><strong>实践：</strong> 如果一个包会被其他项目复用，那么包内的所有类都应该一起被复用。避免将不相关或不同重用频率的类塞进同一个包。</li></ul></li><li><p><strong>共同封闭原则(Common Closure Principle - CCP)</strong></p><ul><li><strong>核心思想：</strong> 包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包则不造成任何影响。</li><li><strong>为什么重要：</strong> 提高可维护性。将可能因相同原因（如需求变更、技术栈升级）而需要一起修改的类放在同一个包中。这样，修改可以局限在一个包内，减少影响范围。</li><li><strong>实践：</strong> 将服务于同一功能域或业务能力的类放在一起。例如，所有与“用户管理”相关的类（<code>User</code>, <code>UserRepository</code>, <code>UserService</code>, <code>UserController</code>）放入<code>com.example.user</code>包。</li></ul></li><li><p><strong>共同重用原则 (Common Reuse Principle - CRP)</strong></p><ul><li><strong>核心思想：</strong> 一个包中的所有类应该是被一起重用的。如果重用了包中的一个类，就应该重用包中的所有类。</li><li><strong>为什么重要：</strong> 避免使用者被迫依赖他们不需要的类，减少不必要的依赖和编译/部署负担。防止包内存在无关紧要的类。</li><li><strong>实践：</strong> 如果一个包中的某些类很少被一起使用，或者使用者只需要其中一部分类，就应该考虑将这些类拆分到不同的包中。CRP 和 CCP 经常需要权衡：CCP 倾向于把一起变化的类放一起（利于修改），CRP 倾向于把一起使用的类放一起（利于重用）。好的设计需要平衡这两者。</li></ul></li><li><p><strong>无环依赖原则 (Acyclic Dependencies Principle - ADP)</strong></p><ul><li><strong>核心思想：</strong> 在包的依赖关系图中不应该存在环（循环依赖）。包的依赖结构必须是一个有向无环图。</li><li><strong>为什么重要：</strong> 循环依赖会导致： <ul><li><strong>编译/构建困难：</strong> 需要同时编译或特殊处理。</li><li><strong>部署困难：</strong> 需要同时部署。</li><li><strong>理解困难：</strong> 包之间高度耦合，难以独立修改。</li><li><strong>单元测试困难：</strong> 难以隔离测试。</li></ul></li><li><strong>如何解决：</strong> 应用依赖倒置原则（DIP），引入接口/抽象层；重构代码，将引起循环的类提取到新包（可能是共同依赖的包）；使用事件、回调等机制解耦。</li></ul></li><li><p><strong>稳定依赖原则 (Stable Dependencies Principle - SDP)</strong></p><ul><li><strong>核心思想：</strong> 朝着稳定的方向进行依赖。一个包应该只依赖于比它更稳定（更不容易改变）的包。</li><li><strong>为什么重要：</strong> 不稳定的包（经常变化的包）如果被许多其他包依赖，那么它的任何修改都会产生广泛的涟漪效应，导致系统脆弱。SDP 将易变性隔离在不稳定的包中，保护稳定的核心部分。</li><li><strong>衡量稳定性：</strong> 可以用<strong>不稳定性</strong> <code>I = Fan-out / (Fan-in + Fan-out)</code> 来衡量（Fan-out：依赖的外部包数量，Fan-in：依赖此包的包数量）。<code>I=0</code> 表示非常稳定（很多包依赖它，它不依赖别人），<code>I=1</code> 表示非常不稳定（它依赖很多包，没有包依赖它）。SDP 要求 <code>I</code> 值应该沿着依赖方向递减。</li></ul></li><li><p><strong>稳定抽象原则 (Stable Abstractions Principle - SAP)</strong></p><ul><li><strong>核心思想：</strong> 一个包的抽象程度应该与其稳定程度一致。稳定的包（高 Fan-in）应该是抽象的包（包含接口、抽象类）；不稳定的包（高 Fan-out）应该是具体的包（包含具体实现）。</li><li><strong>为什么重要：</strong> 稳定包（不易改变）如果是抽象的（接口），那么依赖它的包只依赖于抽象契约，具体实现可以灵活变化（甚至替换），这符合开闭原则（OCP）。如果稳定包是具体的，那么它的任何具体实现的修改都会强制依赖它的包重新编译/修改，违背了OCP。</li><li><strong>衡量抽象性：</strong> 可以用<strong>抽象性</strong> <code>A = (#抽象类+ #接口) / (#类总数)</code> 来衡量。SAP 要求稳定包（低 <code>I</code>）应该有高 <code>A</code>（抽象），不稳定包（高 <code>I</code>）可以有低 <code>A</code>（具体）。理想情况下，<code>A</code> 和 <code>I</code> 应该形成一个平衡（如 <code>A + I ≈ 1</code>），即主序列（Main Sequence）。</li></ul></li></ol><h3 id="包原则总结表" tabindex="-1">包原则总结表 <a class="header-anchor" href="#包原则总结表" aria-label="Permalink to “包原则总结表”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">原则名称</th><th style="text-align:left;">缩写</th><th style="text-align:left;">核心关注点</th><th style="text-align:left;">关键目标</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>重用发布等价原则</strong></td><td style="text-align:left;">REP</td><td style="text-align:left;">包内类的<strong>重用性</strong></td><td style="text-align:left;">包是可独立发布、重用的单元</td></tr><tr><td style="text-align:left;"><strong>共同封闭原则</strong></td><td style="text-align:left;">CCP</td><td style="text-align:left;">包内类的<strong>可维护性</strong>（变化）</td><td style="text-align:left;">将一起变化的类放在一起，减少修改影响</td></tr><tr><td style="text-align:left;"><strong>共同重用原则</strong></td><td style="text-align:left;">CRP</td><td style="text-align:left;">包内类的<strong>可重用性</strong>（使用）</td><td style="text-align:left;">避免使用者依赖不需要的类</td></tr><tr><td style="text-align:left;"><strong>无环依赖原则</strong></td><td style="text-align:left;">ADP</td><td style="text-align:left;"><strong>包间依赖结构</strong></td><td style="text-align:left;">消除循环依赖，构建有向无环图</td></tr><tr><td style="text-align:left;"><strong>稳定依赖原则</strong></td><td style="text-align:left;">SDP</td><td style="text-align:left;"><strong>依赖方向</strong></td><td style="text-align:left;">依赖稳定的包，隔离不稳定变化</td></tr><tr><td style="text-align:left;"><strong>稳定抽象原则</strong></td><td style="text-align:left;">SAP</td><td style="text-align:left;"><strong>包的稳定性与抽象程度的关系</strong></td><td style="text-align:left;">稳定包应是抽象的，便于扩展</td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><ul><li><strong>类级别原则 (SOLID + LoD + 组合)</strong> 指导如何设计健壮、灵活、可维护的单个类以及类间关系。</li><li><strong>包/模块级别原则 (REP, CCP, CRP, ADP, SDP, SAP)</strong> 指导如何将类组织成更大的、内聚的、可管理的单元，并管理这些单元之间的依赖关系，确保整个系统架构的稳定性和可维护性。</li><li>这些原则相互关联，共同作用。例如，遵循 DIP 有助于实现 ADP 和 SDP；遵循 SRP 有助于更好地应用 REP、CCP、CRP 进行包划分。</li><li>应用这些原则需要权衡和判断，没有绝对完美的方案。理解原则背后的<strong>目标</strong>（降低耦合、提高内聚、增强灵活性、可维护性、可扩展性）比机械套用更重要。结合具体的项目需求、规模和上下文来应用这些原则是关键。</li></ul>`,12)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};