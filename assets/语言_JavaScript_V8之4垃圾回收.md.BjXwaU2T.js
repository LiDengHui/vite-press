import{_ as d,I as r,c as p,o as l,a7 as c,j as a,a as i,J as n,w as e}from"./chunks/framework.DDkSvsBP.js";const w=JSON.parse('{"title":"V8之4垃圾回收","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/V8之4垃圾回收.md","filePath":"语言/JavaScript/V8之4垃圾回收.md","lastUpdated":1750738239000}'),h={name:"语言/JavaScript/V8之4垃圾回收.md"},m={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"4.679ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 2068.1 915.9","aria-hidden":"true"},T={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.186ex"},xmlns:"http://www.w3.org/2000/svg",width:"6.816ex",height:"2.072ex",role:"img",focusable:"false",viewBox:"0 -833.9 3012.6 915.9","aria-hidden":"true"};function g(Q,s,k,b,f,u){const t=r("mjx-assistive-mml"),o=r("mjx-container");return l(),p("div",null,[s[7]||(s[7]=c(`<h1 id="v8之4垃圾回收" tabindex="-1">V8之4垃圾回收 <a class="header-anchor" href="#v8之4垃圾回收" aria-label="Permalink to “V8之4垃圾回收”">​</a></h1><p>垃圾回收器是一把十足的双刃剑。其好处是可以大幅简化程序的内存管理代码，因为内存管理无需程序员来操作，由此也减少了（但没有根除）长时间运转程序的内存泄漏。对于某些程序员来说，它甚至能够提升代码的性能。</p><p>另一方面，选择垃圾回收器也就意味着程序当中无法完全掌握内存，而这正是移动终端开发的症结。对于JavaScript，程序中没有任何内存管理的可能--ECMAScript标准中没有暴露任何垃圾回收器的接口。网页应用即没有办法管理内存，也没有办法给垃圾回收器进行提示。</p><p>严格来讲，使用垃圾回收器的语言在性能上并不一定比不使用垃圾回收器的语言好或差。在C语言中，分配和释放内存有可能是非常昂贵的操作，为了使分配的内存能够在将来释放，堆的管理会趋于复杂。而在托管内存的语言中，分配内存往往只是增加一个指针。但随后我们就会看到，当内存耗尽时，垃圾回收器介入回收所产生的巨大代价。一个未经琢磨的垃圾回收器，会致使程序在运行中出现长时间、无法预期的停顿，这直接影响到交互系统（特别是带有动画效果的）在使用上的体验。引用计数系统时常被吹捧为垃圾回收机制的替代品，但当大型子图中的最后一个对象的引用解除后，同样也会有无法预期的停顿。而且引用计数系统在频繁执行读取、改写、存储操作时，也会有可观的性能负担。</p><p>或好或坏，JavaScript需要一个垃圾回收器。V8的垃圾回收器实现现在已经成熟，其性能优异，停顿短暂，性能负担也非常可控。</p><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to “基本概念”">​</a></h2><p>垃圾回收器要解决的最基本的问题就是，辨别需要回收的内存。一旦辨别完毕，这些内存区域即可在未来的分配中重用，或者返还给操作系统。一个对象当它不是处于活跃状态的时候它就死了。一个对象处于活跃状态，当且仅当它被一个根对象或者另一个活跃对象指向。根对象被定义为处于活跃状态，是浏览器或V8所引用的对象。比如说，被局部变量所指向的对象属于根对象，因为它们的栈被视为根对象；全局对象属于根对象，因为它们始终可被访问；浏览器对象，如DOM元素，也属于根对象，尽管在某些场合下他们只是弱引用。</p><p>从侧面来说，上面的定义非常宽松。实际上我们可以说，当一个对象可被程序引用时，它就是活跃的。比如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {x: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	  g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可能包含一个死循环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre></div><p>译注： 这里的obj.x和obj都是活跃的，尽管对其的再度引用是在死循环之后。</p><p>很遗憾，我们无法精确地解决这个问题，因为这个问题实际等价于停机问题，无法确定。因此我们做一个等价约定： 如果一个对象可经由某个被定义为活跃对象的对象，通过某个指针所访问，则它就是活跃的。其他的都被视为垃圾。</p><h2 id="堆的构成" tabindex="-1">堆的构成 <a class="header-anchor" href="#堆的构成" aria-label="Permalink to “堆的构成”">​</a></h2><p>在我们深入研究垃圾回收器的内部工作原理之前，首先看看堆是如何组织的。V8讲堆分为了几个不同的区域：</p><ol><li>新生区： 大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。</li><li>老生指针区：这里包含大多数可能存在指向其他数据对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。</li><li>老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未被封箱的双精度数字数组，在新生区存活一段时间后会被移送到这里。</li><li>大对象区：这里存放体积超越其他区大小的对象。每个对象有自己mmap产生的内存。垃圾回收器从不移动大对象。</li><li>代码区：代码对象，也就是包含JIT之后指令对象，会被分配到这里。这里唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。但大对象内存区本省不是可执行的内存区）</li><li>Cell区、属性Cell区、Map区：这些区存放Cell、属性Cell和Map，每个区域因为都存放相同大小的元素，因此内存结构很简单。</li></ol><p>每个区域都有一组内存页构成。内存页是一块连续的内存，经mmap由操作系统分配而来。除大对象区的内存页比较大之外，每个区的内存页都是1MB大小且按1MB内存对齐。除了存储对象，内存页还含有一个页头（包含一些元数据和标识信息）以及一个位图区（用以标记哪些对象是活跃的）。另外，每个内存页还有一个单独分配在另外内存区的槽缓冲，里面放着一组对象，这些对象可能指向其他存储在该页的对象。这就是一套经典配置方案，其他方案我们稍后讨论。</p><p>有了这些背景知识，我们可以来深入垃圾回收器了。</p><h2 id="识别指针" tabindex="-1">识别指针 <a class="header-anchor" href="#识别指针" aria-label="Permalink to “识别指针”">​</a></h2><p>垃圾回收器面临的第一个问题是，如何才能在堆中区分指针和数据，因为指针指向着活跃的对象。大多数垃圾回收算法会将对象在内存中挪动（以便减少内存碎片，使内存紧凑）,因此即使不区分指针和数据，我们也常常需要对指针进行改写： 目前主要有三种方法来识别指针：</p><ol><li>保守法：这种方法对于缺少编译器支持的情况非常必要。大体上，我们将所有堆上对齐的字都认为是指针，这就意味着有些数据也会被认为是指针。于是某些实际是数字的假指针，会被误认为指向活跃的对象，则我们会时常出现一些奇怪的内存泄漏（因为垃圾回收器会以为死对象仍然还有指针指向，错将死对象误认为活跃对象）而且我们页不能移动任何内存区域，因为这很可能会导致数据遭到破坏。这样，我们便无法通过紧凑内存来获得任何好处（比如更容易的分配内存、更少的内存访问、更有效的内存局部性缓存）。C/C++的垃圾回收器扩展会采用这种方式，比如Boehm-Demers-Weiser。译注： 如果内存是紧凑的，则内存分配时可以更容易分配较大片的内存，而无需因内存碎片而不断查找；同时，由于已分配的内存是连续或近似连续的，而Cache所能缓存的内存有限，如果内存被Cache缓存起来，无需频繁的迫使Cache更换缓存的内存。C/C++由于指针算术的存在，编译器无法确定哪些内存是真正的垃圾，因而无法给垃圾回收器有效的指示，进而导致垃圾回收器不得不采取这样的保守策略。</li><li>编译器提示法：如果我们和静态语言打交道，则编译器能够准确告诉我们每个类当中指针的具体位置。而一旦我们知道对象是哪个类实例化得到的，我们就能知道对象中所有的指针。JVM 选择了这样的方法来垃圾回收。可惜，这种方法对于JS这样的动态语言来说不太好使，因为JS中对象的任何属性即是指针，也可能是数据。</li><li>标记指针法：这种方法需要在每个字的末尾预留一位来标记这个字代表的是指针抑或数据。这种方法需要一定的编译支持，但实现简单，而且性能不俗。V8采用的就是这种方法。某些静态语言也采用了这样的方法，如OCaml</li></ol>`,19)),a("p",null,[s[4]||(s[4]=i("V8将所有属于")),n(o,{class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},{default:e(()=>[(l(),p("svg",m,s[0]||(s[0]=[a("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[a("g",{"data-mml-node":"math"},[a("g",{"data-mml-node":"mo"},[a("path",{"data-c":"2212",d:"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z",style:{"stroke-width":"3"}})]),a("g",{"data-mml-node":"msup",transform:"translate(778,0)"},[a("g",{"data-mml-node":"mn"},[a("path",{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z",style:{"stroke-width":"3"}})]),a("g",{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"},[a("g",{"data-mml-node":"mn"},[a("path",{"data-c":"33",d:"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z",style:{"stroke-width":"3"}}),a("path",{"data-c":"30",d:"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z",transform:"translate(500,0)",style:{"stroke-width":"3"}})])])])])],-1)]))),n(t,{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},{default:e(()=>s[1]||(s[1]=[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mo",null,"−"),a("msup",null,[a("mn",null,"2"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mn",null,"30")])])],-1)])),_:1,__:[1]})]),_:1}),s[5]||(s[5]=i("...")),n(o,{class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},{default:e(()=>[(l(),p("svg",T,s[2]||(s[2]=[a("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[a("g",{"data-mml-node":"math"},[a("g",{"data-mml-node":"msup"},[a("g",{"data-mml-node":"mn"},[a("path",{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z",style:{"stroke-width":"3"}})]),a("g",{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"},[a("g",{"data-mml-node":"mn"},[a("path",{"data-c":"33",d:"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z",style:{"stroke-width":"3"}}),a("path",{"data-c":"30",d:"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z",transform:"translate(500,0)",style:{"stroke-width":"3"}})])])]),a("g",{"data-mml-node":"mo",transform:"translate(1512.3,0)"},[a("path",{"data-c":"2212",d:"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z",style:{"stroke-width":"3"}})]),a("g",{"data-mml-node":"mn",transform:"translate(2512.6,0)"},[a("path",{"data-c":"31",d:"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z",style:{"stroke-width":"3"}})])])],-1)]))),n(t,{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},{default:e(()=>s[3]||(s[3]=[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("msup",null,[a("mn",null,"2"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mn",null,"30")])]),a("mo",null,"−"),a("mn",null,"1")],-1)])),_:1,__:[3]})]),_:1}),s[6]||(s[6]=i("范围内的小整数（V8内部称其为Smis）以32bit字宽来存储，其中的最低位保持位0，而指针的最低两位则为01.由于对象以4字节对齐，因此这样表达指针没有任何问题。大多数对象所含有的只是一组标记后的字，因此垃圾回收可以进行很快。而有些类型的对象，比如字符串，我们确定它只包含有数据，因此无需标记。"))]),s[8]||(s[8]=c(`<h2 id="分代回收" tabindex="-1">分代回收 <a class="header-anchor" href="#分代回收" aria-label="Permalink to “分代回收”">​</a></h2><p>脚本中，绝大多数对象的生存期很短，只有某些对象的生存期较长。为利用这一特点，V8将堆进行了分代。对象起初会被分配在新生区（通常狠小，只有1-8MB，具体根据行为来进行启发）。在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针到达了新生代的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。对于活跃超过两个周期的对象，则需将其移动至老生区。老生区在标记-清除或标记-紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象到老生区后才会发生，至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。</p><p>由于清理发生的频繁，清理必须进行的非常快速。V8中的清理过程称为Scavenge算法，是按照Cheney的算法实现的。这个算法的大致是，新生区被划分为两个等大的子区：出区、入区。绝大多数内存的分配都会在出区发生（但某些特定类型的对象，如可执行的代码对象是分配在老生区的），当出区耗尽时，我们交换出区和入区（这样所有的对象都归属于入区当中），然后将入区中活跃的对象复制到出区或老生区当中。在这时我们会对活跃对象进行紧缩，以便提升Cache的内存局限性，保持内存分配的简洁快速。</p><p>一下是这个算法的伪代码描述：</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span></span></span>
<span class="line"><span>def scavenge():</span></span>
<span class="line"><span>  swap(fromSpace, toSpace)</span></span>
<span class="line"><span>  allocationPtr = toSpace.bottom</span></span>
<span class="line"><span>  scanPtr = toSpace.bottom</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for i = 0..len(roots):</span></span>
<span class="line"><span>    root = roots[i]</span></span>
<span class="line"><span>    if inFromSpace(root):</span></span>
<span class="line"><span>      rootCopy = copyObject(&amp;allocationPtr, root)</span></span>
<span class="line"><span>      setForwardingAddress(root, rootCopy)</span></span>
<span class="line"><span>      roots[i] = rootCopy</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  while scanPtr &lt; allocationPtr:</span></span>
<span class="line"><span>    obj = object at scanPtr</span></span>
<span class="line"><span>    scanPtr += size(obj)</span></span>
<span class="line"><span>    n = sizeInWords(obj)</span></span>
<span class="line"><span>    for i = 0..n:</span></span>
<span class="line"><span>      if isPointer(obj[i]) and not inOldSpace(obj[i]):</span></span>
<span class="line"><span>        fromNeighbor = obj[i]</span></span>
<span class="line"><span>        if hasForwardingAddress(fromNeighbor):</span></span>
<span class="line"><span>          toNeighbor = getForwardingAddress(fromNeighbor)</span></span>
<span class="line"><span>        else:</span></span>
<span class="line"><span>          toNeighbor = copyObject(&amp;allocationPtr, fromNeighbor)</span></span>
<span class="line"><span>          setForwardingAddress(fromNeighbor, toNeighbor)</span></span>
<span class="line"><span>        obj[i] = toNeighbor</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def copyObject(*allocationPtr, object):</span></span>
<span class="line"><span>  copy = *allocationPtr</span></span>
<span class="line"><span>  *allocationPtr += size(object)</span></span>
<span class="line"><span>  memcpy(copy, object, size(object))</span></span>
<span class="line"><span>  return copy</span></span></code></pre></div><p>在这个算法的执行过程中，我们始终维护两个出区中的指针： allocationPtr 指向我们即将为新对象分配内存的地方，scanPtr 指向我们即将进行活跃检查的下一个对象。scanPtr 所指向地址之前的对象是处理过的对象，它们及其相邻接都在出区，其指针都是更新过的，位于scanPtr和allocationPtr之间的对象，会被复制至出区，但这些对象内部所包含的指针如果指向入区中的对象，则这些入区中的对象不会被复制。逻辑上，你可以将scanPtr和 allocationPte之间的对象想象为一个广度优先搜索用到的对象队列。</p><p>译注：广度优先搜索中，通常会将节点从队列头部取出并展开，将展开得到的子节点存入队列末端，周而复始进行，这一过程与更新两个指针对象的过程相似。</p><p>我们在算法的初始时，复制新区所有可从根对象到达的对象，之后进入一个大循环。在循环的每一轮，我们都会从队列中删除一个对象，也就是对scanPtr增量，然后跟踪访问对象内部的指针。如果指针并不指向入区中某个对象，但我们还没有复制（未设置转发地址），则将这个对象复制出区，即增加到我们队列的末端，同时也就是对allocationPtr增量。这时我们还会将一个转发地址存至出区对象的首字，替换掉Map指针。这个转发地址就是对象复制后所存放的地址。垃圾回收器可以轻易将转发地址与Map指针分清，因为Map指针经过了标记，而这个地址则未标记。如果我们发现一个指针，而其指向的对象已经复制过了（设置过转发地址），我们就把这个指针更新为转发地址，然后打上标记。</p><p>算法在所有对象都处理完毕时终止（即scanPtr和allocationPtr相遇）。这时入区的内容都可视为垃圾，可能会在未来释放或重用。</p><h2 id="秘密武器-写屏障" tabindex="-1">秘密武器： 写屏障 <a class="header-anchor" href="#秘密武器-写屏障" aria-label="Permalink to “秘密武器： 写屏障”">​</a></h2><p>上面有一个细节被忽略了： 如果新生区的某个对象，只有一个指向它的指针，而这个指针恰好在老生区的对象中，我们如何才能知道新生区中哪个对象是活跃的呢？显然我们并不希望将老生区再遍历一次，因为老生区中的对象很多，这样做一次消耗太大。</p><p>为了解决这个问题，实际上再写缓冲区中有一个列表，列表中记录了所有老生区对象指向新生区的情况。新对象诞生的时候，并不会有指向它的指针，而当老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。由于这种记录行为总是发生在写操作时，它被称为写屏障————因为每次操作都要经历这样一关。</p><p>你可能好奇，如果每次进行写操作都要经过写屏障，岂不是会多出大量的代码么？没错，这就是我们这种垃圾回收机制的代价之一。但情况没你现象的那么严重，写操作毕竟比读操作要少。某些垃圾回收算法（不是V8的）会采用读屏障，而这需要硬件来辅助才能保证一个较低的消耗。V8也有一些优化来降低写屏障带来的消耗：</p><ol><li>大多数的脚本执行时间都是发生在Crankshaft当中的，而Crankshaft常常能静态地判断出某个对象是否处于新生区。对于指向这些对象的写操作，可以无需写屏障。</li><li>Crankshaft中新出现了一种优化，即在对象不存在指向它的非局部引用时，该对象会被分配在栈上。而一个栈上对象的相关写操作显然无需写屏障。（注：新生区与老生区在堆上）</li><li>“老-&gt; 新”这样的情况相对较为少见，因此通过将“新-&gt;新”和“老-&gt;老”两种常见情况的代码做优化，可以相对提升多数情形下的性能。每个页都以1MB对齐，因此给定一个对象的内存地址，通过将低20bit滤除来快速定位其所在的页；而页头有相关的标识来表明其属于新生区还是老生区，因此通过判断两个对象所属的区域，也可以快速确定是否是“老-&gt;新”。</li><li>一旦我们找到“老-&gt;新”的指针，我们就可以将其记录在写缓冲区的末端。经过一定的时间（写缓冲区满的时候），我么将其排序，合并相同的项目，然后再除去已经不符合“老-&gt;新”这一情形的指针（注：这样指针的数目就会减少，写屏障的时间相应也会缩短）。</li></ol><h2 id="标记——清除-算法与-标记——紧缩-算法" tabindex="-1">“标记——清除”算法与“标记——紧缩”算法 <a class="header-anchor" href="#标记——清除-算法与-标记——紧缩-算法" aria-label="Permalink to ““标记——清除”算法与“标记——紧缩”算法”">​</a></h2><p>Scavenge算法对于快速回收、紧缩小片内存效果很好，但对于大片内存则消耗过大。因为Scavenge算法需要出区和入区两个区域，这对于小片内存尚可，而对于超过数MB的内存就开始变得不切实际了。老生区包含有上百MB的数据，对于这么大的区域，我们采取另外两种相互较为接近的算法：“标记 —— 清除”算法与“标记 —— 紧缩”算法。</p><p>这两种算法都包含两个阶段： 标记阶段，清除或紧缩阶段</p><p>在标记阶段，所有堆上的活跃对象都会被标记。每个页都会包含一个用来标记的位图，位图中的每一位对应页中的一字（注：一个指针就是一个字大小）。这个标记非常有必要，因为指针可能会在任何字对齐的地方出现。显然，这样的位图要占据一定的空间（32位系统上占据3.1%,64位系统上占据1.6%,但所有的内存管理机制都需要这样占用，因此这种做法并不过分。除此之外，另有2位来表示标记对象的状态。由于对象至少有2字长，因此这些位不会重叠。状态一共有三种：如果一个对象的状态为白，那么它尚未被垃圾回收器发现；如果一个对象的状态为灰，那么它已经被垃圾回收器发现，但它的邻接对象仍未全部处理完毕了；如果一个对象状态为黑，则它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕。</p><p>如果将堆中的对象看作由指针相互联系的有向图，标记算法的核心实际是深度优先搜索。在标记的初期，位图是空的，所有对象也都是白的。从根可达的对象会被渲染为灰色，并被放入标记用的一个单独分配的双端队列。标记阶段的每次循环，GC会将一个对象从两端队列中取出，染色为黑色，然后将它的邻接对象染成灰色，并把邻接对象放入双端队列。这一过程在双端队列为空所有对象都变黑时结束。特别是大的对象，如长数组，可能会在处理时分片，以防溢出双端队列。如果双端队列溢出了，则对象仍然会被染为灰色，但不会被放入队列（这样它们的邻接对象就没有机会再染色了）。因此当双端队列为空时，GC仍然需要扫描一次，确保所有的对象都成为黑对象。对于未被染黑的灰对象，GC会将其再次放入队列，再度处理。</p><p>以下是标记清除算法的伪代码：</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>markingDeque = []</span></span>
<span class="line"><span>overflow = false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def markHeap():</span></span>
<span class="line"><span>  for root in roots:</span></span>
<span class="line"><span>    mark(root)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  do:</span></span>
<span class="line"><span>    if overflow:</span></span>
<span class="line"><span>      overflow = false</span></span>
<span class="line"><span>      refillMarkingDeque()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    while !markingDeque.isEmpty():</span></span>
<span class="line"><span>      obj = markingDeque.pop()</span></span>
<span class="line"><span>      setMarkBits(obj, BLACK)</span></span>
<span class="line"><span>      for neighbor in neighbors(obj):</span></span>
<span class="line"><span>        mark(neighbor)</span></span>
<span class="line"><span>  while overflow</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span></span></span>
<span class="line"><span>def mark(obj):</span></span>
<span class="line"><span>  if markBits(obj) == WHITE:</span></span>
<span class="line"><span>    setMarkBits(obj, GREY)</span></span>
<span class="line"><span>    if markingDeque.isFull():</span></span>
<span class="line"><span>      overflow = true</span></span>
<span class="line"><span>    else:</span></span>
<span class="line"><span>      markingDeque.push(obj)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def refillMarkingDeque():</span></span>
<span class="line"><span>  for each obj on heap:</span></span>
<span class="line"><span>    if markBits(obj) == GREY:</span></span>
<span class="line"><span>      markingDeque.push(obj)</span></span>
<span class="line"><span>      if markingDeque.isFull():</span></span>
<span class="line"><span>        overflow = true</span></span>
<span class="line"><span>        return</span></span></code></pre></div><p>标记算法结束时，所有的活跃对象都被染为了黑色，而所有的死对象仍是白的。这一结果正是清除和紧缩两个阶段所期望的。</p><p>标记算法执行完毕后，我们可以选择清理或是紧缩，这两个算法都可以回收内存，而且两者都作用于页级（注意，V8的内存页是1MB的连续内存块，与虚拟内存页不同）。</p><p>清理算法扫描连续存放的死对象，将其变为空闲空间，并将其添加到空闲内存链表中。每一页都包含数个空闲内存链表，其分别代表小内存区（&lt;256字）、中内存区 （&lt;2048字）、大内存区（&lt;16384字）和超大内存区（其它更大的内存）。清理算法非常简单，只需遍历页的位图，搜索连续的白对象。空闲内存链表大量被scavenge算法用于分配存活下来的活跃对象，但也被紧缩算法用于移动对象。有些类型的对象只能被分配在老生区，因此空闲内存链表也被它们使用。</p><p>紧缩算法会尝试将对象从碎片页（包含大量小空闲内存页）中迁移整合在一起，来释放内存。这些对象会被迁移到另外的页上，因此也可能会新分配一些页。而迁出后的碎片页就可以返还给操作系统了。迁移整合的过程非常复杂，因此我只提及一些细节而不全面讲解。大概过程就是这样。对目标碎片中的每个活跃对象，在空闲内存链表中分配一块其它页的区域，将该对象复制至新页，并在碎片页中的该对象上写上转发地址，将其更新为新的地址。由于标记过程中也记录了不同页之间的指针，此时也会更新这些指针的指向。注意，如果一个页非常活跃，比如其中有过多需要记录的指针，则地址记录会跳过它，等到下一轮垃圾回收再进行处理。</p><h2 id="增量标记与惰性清理" tabindex="-1">增量标记与惰性清理 <a class="header-anchor" href="#增量标记与惰性清理" aria-label="Permalink to “增量标记与惰性清理”">​</a></h2><p>你因该想到了，当一个堆很大而且很多活跃对象时，标记-清除和标记-紧缩算法会执行的很慢。起初我研究V8时，垃圾回收所引发的500-1000毫秒的停顿并不少见。这种情况显然很难接受，即使是对于移动设备。</p><p>2012年年中，Google引入了两项改进来减少垃圾回收所引起的停顿，并且效果显著：增量标记和惰性清理。</p><p>增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小到达一定的阈值时启用，启用之后没当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就想普通标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。</p><p>但增量标记与普通标记不同的是，对象的图谱关系可能发生变化！我们需要特别注意的是，那些从黑对象指向白对象的新指针。回忆一下，黑对象表示其已完全被垃圾回收器扫描，并不会进行二次扫描。因此如果有“黑-&gt;白”这样的指针出现，我们就有可能将那个白对象漏掉，错当死对象处理掉。（注：标记过程结束后剩余的白对象都被认为是死对象）于是我们不得不再度启用写屏障。现在写屏障不仅记录“老-&gt;新”指针，同时还要记录“黑-&gt;白”指针。一旦发现这样的指针，黑对象会被重新渲染为灰对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。</p><p>增量标记完成后，惰性清理就开始了。所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。此时我们可以不着急释放那些空间，而将清理的过程延迟一下也并无大碍，因此无需一次清理所有的页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。这时增量标记又蓄势待发了。</p><p>Google近期还新增了并行清理支持。由于脚本的执行线程不会再触及死对象，页的清理任务可以放在另一个单独的线程中进行并只需极少的同步工作。同样的支持工作也正在并行标记上开展着，但目前还处于早期实验阶段。</p><ol><li><p><a href="http://www.amazon.com/Garbage-Collection-Algorithms-Automatic-Management/dp/0471941484" target="_blank" rel="noreferrer">Garbage Collection</a></p></li><li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.6386&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noreferrer">Garbage First Garbage-Collection</a></p></li></ol>`,33))])}const y=d(h,[["render",g]]);export{w as __pageData,y as default};
