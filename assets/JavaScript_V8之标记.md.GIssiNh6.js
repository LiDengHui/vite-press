import{_ as o,c as l,o as t,a6 as n}from"./chunks/framework.mq8cK8gF.js";const u=JSON.parse('{"title":"V8 之标记","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/V8之标记.md","filePath":"JavaScript/V8之标记.md","lastUpdated":1750238552000}'),i={name:"JavaScript/V8之标记.md"};function s(g,r,a,e,c,p){return t(),l("div",null,r[0]||(r[0]=[n('<h1 id="v8-之标记" tabindex="-1">V8 之标记 <a class="header-anchor" href="#v8-之标记" aria-label="Permalink to “V8 之标记”">​</a></h1><p>V8 的垃圾回收（GC）中，<strong>标记（Marking）</strong> 阶段是整个回收过程的核心，其目标是准确识别堆内存中所有<strong>可达对象</strong>（存活对象）。V8 采用了一种高效且复杂的标记策略，主要基于 <strong>三色标记法（Tri-color Marking）</strong> 并结合了 <strong>增量标记（Incremental Marking）</strong> 和 <strong>并发标记（Concurrent Marking）</strong> 技术来显著减少 GC 停顿时间（Stop-The-World Pauses）。</p><h3 id="核心-三色标记法-tri-color-marking" tabindex="-1">核心：三色标记法（Tri-color Marking） <a class="header-anchor" href="#核心-三色标记法-tri-color-marking" aria-label="Permalink to “核心：三色标记法（Tri-color Marking）”">​</a></h3><p>这是一种抽象模型，将堆中的对象根据其标记状态分为三类颜色：</p><ol><li><p><strong>白色（White）</strong>：</p><ul><li>初始状态：所有对象在 GC 开始时都是白色。</li><li>含义：<strong>未访问</strong>或<strong>未标记</strong>。GC 结束时，白色对象被视为垃圾，将被回收。</li></ul></li><li><p><strong>灰色（Grey）</strong>：</p><ul><li>含义：对象<strong>已被标记为可达</strong>，但其<strong>直接引用的子对象（属性、元素等）还未被扫描/标记</strong>。</li><li>作用：表示“待处理”。这些对象存放在一个专门的 <strong>标记工作列表（Marking Worklist）</strong> 中。</li></ul></li><li><p><strong>黑色（Black）</strong>：</p><ul><li>含义：对象<strong>已被标记为可达</strong>，并且<strong>其所有直接引用的子对象也已被标记</strong>（即扫描完成）。</li><li>作用：表示“处理完成”。黑色对象是确定存活的。</li></ul></li></ol><h3 id="标记过程-以老生代回收为例" tabindex="-1">标记过程（以老生代回收为例） <a class="header-anchor" href="#标记过程-以老生代回收为例" aria-label="Permalink to “标记过程（以老生代回收为例）”">​</a></h3><ol><li><p><strong>初始化（Initialization）</strong>：</p><ul><li>所有对象设置为<strong>白色</strong>。</li><li><strong>根对象（Roots）</strong> 被识别并放入<strong>标记工作列表（变成灰色）</strong>。根对象包括： <ul><li>全局对象（<code>window</code>/<code>global</code>）。</li><li>当前执行栈上的所有变量（局部变量、参数）。</li><li>激活的函数作用域链。</li><li>编译缓存（字节码、内联缓存）。</li><li>所有 <code>WeakMap</code>、<code>WeakSet</code> 中的键（仅用于标记值，不影响键本身存活）。</li><li>（在 Minor GC 中）写屏障记录的跨代引用（来自老生代指向新生代的指针）。</li></ul></li></ul></li><li><p><strong>标记阶段（Marking Phase）</strong>：</p><ul><li><strong>循环处理工作列表</strong>： <ul><li>从<strong>标记工作列表</strong>中取出一个<strong>灰色</strong>对象。</li><li>扫描这个对象的所有属性（包括数组元素、Map/Set 条目、原型链等），查找它引用的所有子对象。</li><li>对于扫描到的每一个子对象： <ul><li>如果该子对象是<strong>白色</strong>（未标记），则将其标记为<strong>灰色</strong>（放入工作列表）。</li><li>如果该子对象已经是<strong>灰色</strong>或<strong>黑色</strong>（已标记或在处理中），则跳过。</li></ul></li><li>将当前处理的对象标记为<strong>黑色</strong>（表示它及其所有直接引用都已处理完）。</li></ul></li><li><strong>结束条件</strong>：当<strong>标记工作列表为空</strong>时，标记阶段结束。此时所有可达对象都变成了<strong>黑色</strong>，所有不可达对象仍然是<strong>白色</strong>。</li></ul></li></ol><h3 id="关键优化技术-减少停顿时间" tabindex="-1">关键优化技术：减少停顿时间 <a class="header-anchor" href="#关键优化技术-减少停顿时间" aria-label="Permalink to “关键优化技术：减少停顿时间”">​</a></h3><p>标记整个堆（尤其是大型应用的老生代）可能非常耗时，导致明显的应用卡顿（Stop-The-World）。V8 采用以下技术解决：</p><ol><li><p><strong>增量标记（Incremental Marking）</strong>：</p><ul><li><strong>核心思想</strong>：将原本一次性的、长时间的完整标记过程，<strong>拆分成许多小的增量步骤</strong>，穿插在 JavaScript 主线程的执行间隙中执行（利用事件循环的空闲时间）。</li><li><strong>如何实现</strong>： <ul><li>GC 启动增量标记后，每次主线程执行一小段时间 JS 代码（如几毫秒），就暂停 JS 执行，让 GC 执行一小部分标记任务（处理工作列表中的一些灰色对象），然后再恢复 JS 执行。如此反复，直到标记完成。</li></ul></li><li><strong>挑战</strong>：JS 代码在标记过程中<strong>修改了对象图</strong>（添加/删除引用），可能导致标记不准确（漏标活对象 - 导致错误回收，或多标死对象 - 影响不大但浪费内存）。</li><li><strong>解决方案：写屏障（Write Barrier）</strong>： <ul><li>在 JS 代码<strong>写入</strong>对象的属性（即修改引用）时，插入一小段特殊的“屏障”代码。</li><li>当写入操作满足特定条件时（通常是：被写入的对象是<strong>黑色</strong>，且新写入的值是一个<strong>白色</strong>对象），写屏障会将这个<strong>白色</strong>对象<strong>直接标记为灰色</strong>，并放入标记工作列表。</li><li><strong>作用</strong>：确保在增量标记过程中，新产生的、被黑色对象引用的白色对象不会被错误地当成垃圾回收（满足了强三色不变性：黑色对象不能直接指向白色对象）。这是增量标记正确性的关键保障！</li></ul></li></ul></li><li><p><strong>并发标记（Concurrent Marking）</strong>：</p><ul><li><strong>核心思想</strong>：在<strong>后台线程（Worker Threads）</strong> 上执行大部分标记工作，<strong>与 JavaScript 主线程并发执行</strong>（几乎不阻塞主线程）。</li><li><strong>如何实现</strong>： <ul><li>V8 启动一个或多个专用的后台线程。</li><li>主线程负责扫描根对象（快照），并将其放入共享的标记工作列表。</li><li>后台线程不断从工作列表中取出灰色对象，扫描其引用，标记子对象（白变灰），并将其自身变黑。新发现的灰色对象放回工作列表。</li></ul></li><li><strong>挑战</strong>：并发执行时，JS 主线程可能同时修改对象图（添加/删除引用），导致后台标记线程看到不一致的对象图状态。</li><li><strong>解决方案</strong>： <ul><li><strong>写屏障（Write Barrier again）</strong>：同样至关重要！当主线程修改引用时（如设置属性），如果可能破坏标记正确性（如使黑色对象指向白色对象），写屏障会将被引用的白色对象标记为灰色（并记录到工作列表），或者将修改前的引用关系记录下来供后台线程处理。</li><li><strong>原子操作与内存屏障</strong>：确保标记线程和主线程对标记位（颜色）的读写操作是原子的，并且内存可见性得到保障（使用内存屏障指令）。</li><li><strong>保守处理与重新扫描</strong>：并发标记结束时，主线程需要短暂停顿，执行一次<strong>最终标记（Finalization Marking）</strong>。此时主线程会： <ul><li>再次快速扫描根对象（可能发生了变化）。</li><li>处理写屏障在并发阶段积累的所有记录（<code>Marking Deque</code> 或 <code>Remembered Sets</code>）。</li><li>确保所有在并发期间被修改的对象及其影响都被正确处理，完成最终的标记状态确认。这个停顿比一次完整标记的停顿短得多。</li></ul></li></ul></li></ul></li><li><p><strong>其他标记优化</strong>：</p><ul><li><strong>位图标记（Bitmap Marking）</strong>：对象头中不直接存储颜色标记位，而是在独立的内存位图中存储标记信息。这提高了缓存局部性（GC 扫描时连续访问位图），也便于并发标记时减少对对象内存的争用。</li><li><strong>懒惰标记（Lazy Sweeping）</strong>：标记完成后，清除（Sweep）阶段不立即执行，而是延迟到需要分配内存且空闲内存不足时，按需清理内存页。减少一次性停顿。</li><li><strong>并行标记（Parallel Marking）</strong>：在多个后台线程上<strong>并行</strong>执行标记任务（处理工作列表的不同部分），充分利用多核 CPU。这通常与并发标记结合使用。</li></ul></li></ol><h3 id="总结-v8-的标记过程" tabindex="-1">总结 V8 的标记过程 <a class="header-anchor" href="#总结-v8-的标记过程" aria-label="Permalink to “总结 V8 的标记过程”">​</a></h3><ol><li><strong>基于三色抽象</strong>：白（未处理）、灰（待处理）、黑（已处理完）。</li><li><strong>广度优先遍历</strong>：通过工作列表实现，高效遍历对象图。</li><li><strong>增量标记</strong>：拆分成小任务穿插在 JS 执行中，<strong>依赖写屏障保证正确性</strong>，大幅减少感知停顿。</li><li><strong>并发标记</strong>：后台线程执行大部分标记工作，与主线程并发，<strong>极度依赖写屏障和原子操作</strong>保证一致性和正确性，最小化主线程停顿。</li><li><strong>优化手段</strong>：位图标记、懒惰清除、并行标记等进一步提升效率和吞吐量。</li></ol><p>正是通过这些精妙的设计（尤其是三色标记+写屏障+增量/并发），V8 能够在保证垃圾回收正确性的前提下，将 GC 对 JavaScript 应用性能的影响（尤其是卡顿）降到最低，支撑了现代高性能 Web 应用和 Node.js 的运行。</p>',13)]))}const h=o(i,[["render",s]]);export{u as __pageData,h as default};
