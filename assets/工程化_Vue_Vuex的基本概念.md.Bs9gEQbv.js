import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.Cyk5UgWo.js";const i=JSON.parse(`{"title":"Vuex 的基本概念","description":"","frontmatter":{},"headers":[],"relativePath":"工程化/Vue/Vuex的基本概念.md","filePath":"工程化/Vue/Vuex的基本概念.md","lastUpdated":1754714200000}`),a={name:`工程化/Vue/Vuex的基本概念.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="vuex-的基本概念" tabindex="-1">Vuex 的基本概念 <a class="header-anchor" href="#vuex-的基本概念" aria-label="Permalink to “Vuex 的基本概念”">​</a></h1><p>Vuex 是 Vue.js 的官方状态管理库，它的核心作用是集中管理和维护应用的状态（例如，用户登录状态、主题色、购物车数据等），并通过<strong>单向数据流</strong>确保数据的可预测性和一致性。Vuex 使得不同组件之间的状态共享变得更加容易和清晰。</p><h2 id="vuex-的原理" tabindex="-1">Vuex 的原理 <a class="header-anchor" href="#vuex-的原理" aria-label="Permalink to “Vuex 的原理”">​</a></h2><p>Vuex 的核心原理基于 <strong>单向数据流</strong> 和 <strong>响应式数据</strong>。它通过四个主要概念来管理状态：<strong>State</strong>、<strong>Getters</strong>、<strong>Mutations</strong> 和 <strong>Actions</strong>。这些概念的设计使得 Vuex 的工作方式具有高度的可预测性和可维护性。</p><h2 id="_1-state-状态" tabindex="-1">1. <strong>State（状态）</strong> <a class="header-anchor" href="#_1-state-状态" aria-label="Permalink to “1. State（状态）”">​</a></h2><p>Vuex 中的 <strong>state</strong> 就是存储应用的状态数据。它类似于 Vue 组件中的 <code>data</code>，但是它是集中式管理的，所有组件都可以访问并共享它。</p><h3 id="_1-1-响应式" tabindex="-1">1.1 <strong>响应式</strong> <a class="header-anchor" href="#_1-1-响应式" aria-label="Permalink to “1.1 响应式”">​</a></h3><p>Vuex 的 <code>state</code> 是响应式的，意味着当 <code>state</code> 发生变化时，所有依赖该 <code>state</code> 的组件会自动更新。这依赖于 Vue 的响应式系统。</p><h3 id="_1-2-定义方式" tabindex="-1">1.2 <strong>定义方式</strong> <a class="header-anchor" href="#_1-2-定义方式" aria-label="Permalink to “1.2 定义方式”">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  state: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="_2-getters-获取器" tabindex="-1">2. <strong>Getters（获取器）</strong> <a class="header-anchor" href="#_2-getters-获取器" aria-label="Permalink to “2. Getters（获取器）”">​</a></h2><p><strong>Getters</strong> 是 Vuex 中的计算属性，用来从 <code>state</code> 中派生出一些状态数据。你可以将 <code>getters</code> 看作是 <code>state</code> 的 <strong>过滤器</strong> 或 <strong>计算值</strong>。</p><ul><li><strong>作用</strong>：<code>getters</code> 用于获取 <code>state</code> 的数据，并可以对数据进行计算或转换。</li><li><strong>响应式</strong>：<code>getters</code> 也是响应式的，当 <code>state</code> 改变时，<code>getters</code> 会自动重新计算。</li></ul><h3 id="_2-1-定义方式" tabindex="-1">2.1 <strong>定义方式</strong> <a class="header-anchor" href="#_2-1-定义方式" aria-label="Permalink to “2.1 定义方式”">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  state: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  getters: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 计算 \`count\` 的平方</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    squaredCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>你可以通过 <code>store.getters.squaredCount</code> 来访问该值。</li></ul><h2 id="_3-mutations-突变" tabindex="-1">3. <strong>Mutations（突变）</strong> <a class="header-anchor" href="#_3-mutations-突变" aria-label="Permalink to “3. Mutations（突变）”">​</a></h2><p><strong>Mutations</strong> 是 Vuex 中唯一可以改变 <code>state</code> 的地方。Vuex 强制要求我们通过提交 <code>mutation</code> 来修改 <code>state</code>，这是一种同步操作。</p><h3 id="_3-1-为什么要使用-mutations" tabindex="-1">3.1 <strong>为什么要使用 Mutations？</strong> <a class="header-anchor" href="#_3-1-为什么要使用-mutations" aria-label="Permalink to “3.1 为什么要使用 Mutations？”">​</a></h3><ul><li><strong>追踪变更</strong>：每个 mutation 都是同步的，并且是可追踪的。因此，开发者可以在开发过程中轻松地进行状态追踪。</li><li><strong>调试</strong>：使用 mutation 使得状态变化可预测。开发者可以记录每次变更的发生，轻松地回溯和查看历史。</li></ul><h3 id="_3-2-定义方式" tabindex="-1">3.2 <strong>定义方式</strong> <a class="header-anchor" href="#_3-2-定义方式" aria-label="Permalink to “3.2 定义方式”">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  state: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mutations: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 增加计数器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 减少计数器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    decrement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>你可以通过 <code>store.commit(&#39;increment&#39;)</code> 来提交 <code>mutation</code>，从而更新 <code>state</code>。</li></ul><h2 id="_4-actions-动作" tabindex="-1">4. <strong>Actions（动作）</strong> <a class="header-anchor" href="#_4-actions-动作" aria-label="Permalink to “4. Actions（动作）”">​</a></h2><p><strong>Actions</strong> 用于处理 <strong>异步操作</strong>，比如发起 HTTP 请求、获取远程数据、定时器等。<code>actions</code> 可以通过 <code>commit</code> 提交 <code>mutation</code> 来改变 <code>state</code>，但它本身不直接修改 <code>state</code>。<code>actions</code> 中可以包含异步代码。</p><h3 id="_4-1-为什么要使用-actions" tabindex="-1">4.1 <strong>为什么要使用 Actions？</strong> <a class="header-anchor" href="#_4-1-为什么要使用-actions" aria-label="Permalink to “4.1 为什么要使用 Actions？”">​</a></h3><ul><li><strong>异步操作</strong>：<code>mutations</code> 必须是同步的，而 <code>actions</code> 允许你进行异步操作，并在异步操作完成后再提交 <code>mutation</code>。</li><li><strong>业务逻辑</strong>：<code>actions</code> 通常用于执行应用的逻辑，例如数据请求、异步计时等。</li></ul><h3 id="_4-2-定义方式" tabindex="-1">4.2 <strong>定义方式</strong> <a class="header-anchor" href="#_4-2-定义方式" aria-label="Permalink to “4.2 定义方式”">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  state: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mutations: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actions: {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> incrementAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;increment&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>你可以通过 <code>store.dispatch(&#39;incrementAsync&#39;)</code> 来调用 <code>action</code>，触发异步操作。</li></ul><h2 id="_5-模块化-modules" tabindex="-1">5. <strong>模块化（Modules）</strong> <a class="header-anchor" href="#_5-模块化-modules" aria-label="Permalink to “5. 模块化（Modules）”">​</a></h2><p>Vuex 允许将 <strong>store</strong> 分割成多个模块，每个模块都有自己的 <code>state</code>、<code>mutations</code>、<code>actions</code> 和 <code>getters</code>，以便在大型应用中进行状态管理的分隔。</p><h3 id="_5-1-模块化的好处" tabindex="-1">5.1 <strong>模块化的好处</strong> <a class="header-anchor" href="#_5-1-模块化的好处" aria-label="Permalink to “5.1 模块化的好处”">​</a></h3><ul><li>在大型项目中，随着项目变得越来越复杂，<code>store</code> 可能会非常庞大。使用模块化可以避免 <code>store</code> 过于臃肿。</li><li>每个模块可以有自己的状态、变更和行为，使得代码更加清晰、可维护。</li></ul><h3 id="_5-2-定义方式" tabindex="-1">5.2 <strong>定义方式</strong> <a class="header-anchor" href="#_5-2-定义方式" aria-label="Permalink to “5.2 定义方式”">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  modules: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    counter: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      state: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      mutations: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      actions: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        incrementAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;increment&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>通过 <code>store.state.counter.count</code> 访问模块状态。</li><li>通过 <code>store.dispatch(&#39;counter/incrementAsync&#39;)</code> 调用模块中的 <code>action</code>。</li></ul><h2 id="vuex-的工作流程" tabindex="-1">Vuex 的工作流程 <a class="header-anchor" href="#vuex-的工作流程" aria-label="Permalink to “Vuex 的工作流程”">​</a></h2><ol><li><strong>组件访问状态</strong>：组件通过 <code>this.$store.state</code> 访问 Vuex 中的 <code>state</code>。</li><li><strong>触发 mutation</strong>：组件通过 <code>this.$store.commit(&#39;mutationName&#39;)</code> 触发 <code>mutation</code>，从而修改 <code>state</code>。</li><li><strong>异步操作</strong>：如果需要异步操作，组件会通过 <code>this.$store.dispatch(&#39;actionName&#39;)</code> 调用 <code>actions</code>，<code>actions</code> 处理异步逻辑并最终通过 <code>commit</code> 提交 <code>mutation</code> 来修改 <code>state</code>。</li><li><strong>响应式更新</strong>：由于 Vuex 中的 <code>state</code> 是响应式的，一旦 <code>state</code> 发生变化，所有依赖该 <code>state</code> 的组件会自动重新渲染。</li></ol><h2 id="_6-vuex-的设计理念" tabindex="-1">6. <strong>Vuex 的设计理念</strong> <a class="header-anchor" href="#_6-vuex-的设计理念" aria-label="Permalink to “6. Vuex 的设计理念”">​</a></h2><p>Vuex 的设计理念是 <strong>单向数据流</strong> 和 <strong>集中式状态管理</strong>，通过以下特点来保证数据流的清晰性：</p><ul><li><strong>单一数据源</strong>：应用中的所有状态都存储在一个单一的 <code>store</code> 中。</li><li><strong>只有 mutation 能改变 state</strong>：通过 mutation 来同步修改状态，确保数据的可追踪性。</li><li><strong>Actions 用于处理异步操作</strong>：所有异步操作都通过 actions 来处理，从而确保 <code>mutation</code> 是同步的。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><p>Vuex 通过集中式管理和单向数据流确保了应用的状态和行为的可预测性。其基本原理包括：</p><ul><li><strong>State</strong>：应用的状态数据。</li><li><strong>Getters</strong>：派生状态，用于计算和过滤。</li><li><strong>Mutations</strong>：用于同步修改状态的唯一方法。</li><li><strong>Actions</strong>：用于处理异步操作，并最终提交 <code>mutation</code>。</li></ul><p>Vuex 的设计理念保证了应用的状态始终清晰和可维护，尤其适用于中大型 Vue 应用的状态管理。</p>`,46)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};