import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.Cyk5UgWo.js";const i=JSON.parse(`{"title":"浏览器渲染页面","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/渲染流程/浏览器渲染页面.md","filePath":"浏览器/渲染流程/浏览器渲染页面.md","lastUpdated":1751344787000}`),a={name:`浏览器/渲染流程/浏览器渲染页面.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="浏览器渲染页面" tabindex="-1">浏览器渲染页面 <a class="header-anchor" href="#浏览器渲染页面" aria-label="Permalink to “浏览器渲染页面”">​</a></h1><p>浏览器解析 HTML 和渲染页面是一个复杂但高度优化的流水线过程，称为 <strong>关键渲染路径</strong>。主要步骤分解如下：</p><h2 id="🧱-1-构建-dom-树" tabindex="-1">🧱 1. 构建 DOM 树 <a class="header-anchor" href="#🧱-1-构建-dom-树" aria-label="Permalink to “🧱 1.  构建 DOM 树”">​</a></h2><ul><li><strong>输入：</strong> 原始 HTML 字节流。</li><li><strong>过程：</strong><ul><li><strong>字节 → 字符：</strong> 浏览器将字节解码为字符（根据文件编码，如 UTF-8）。</li><li><strong>字符 → Tokens：</strong> 分词器将字符流分解为符合 HTML 标准的词法单元（Tokens），如 <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;div&gt;</code>, <code>&quot;text&quot;</code> 等。</li><li><strong>Tokens → Nodes：</strong> 语法分析器（Parser）根据 HTML 规范（特别是树构建阶段）将这些 Tokens 解析成有层次结构的对象，即节点（Nodes）。每个节点代表 HTML 文档中的一个元素、属性、文本内容、注释等。</li><li><strong>Nodes → DOM Tree：</strong> 节点按照其在文档中的父子、兄弟关系连接起来，形成一颗树状结构——<strong>文档对象模型树</strong>。DOM 树是 HTML 文档在内存中的完整对象表示，也是 JavaScript 操作页面的主要接口。</li></ul></li><li><strong>特点：</strong><ul><li><strong>渐进式：</strong> 浏览器不会等到整个 HTML 下载完才开始解析。它是边下载边解析的。</li><li><strong>阻塞 JS/CSS：</strong> 遇到 <code>&lt;script&gt;</code> 标签（尤其是没有 <code>async</code> 或 <code>defer</code> 属性的）会<strong>暂停 HTML 解析</strong>，立即下载（如果需要）并执行脚本，因为 JS 可能修改 DOM。遇到 <code>&lt;link&gt;</code> 引入的 CSS 会<strong>并行下载</strong>，但构建 CSSOM 会阻塞后续 JS 执行和渲染（见下一步）。</li></ul></li></ul><h2 id="🎨-2-构建-cssom-树" tabindex="-1">🎨 2. 构建 CSSOM 树 <a class="header-anchor" href="#🎨-2-构建-cssom-树" aria-label="Permalink to “🎨 2.  构建 CSSOM 树”">​</a></h2><ul><li><strong>输入：</strong> 所有 CSS 来源（外部样式表、内联样式、<code>&lt;style&gt;</code> 标签、浏览器默认样式）。</li><li><strong>过程：</strong><ul><li>与 DOM 构建类似：字节 → 字符 → Tokens → Nodes。</li><li>节点根据 CSS 级联、继承和特异性规则连接成一棵树状结构——<strong>CSS 对象模型树</strong>。CSSOM 树包含了页面所有元素的<strong>最终计算样式</strong>（Computed Style）。</li></ul></li><li><strong>特点：</strong><ul><li><strong>级联：</strong> 解决多个来源、选择器冲突的样式规则，确定最终值。</li><li><strong>阻塞渲染：</strong> 浏览器必须拥有完整的 CSSOM 才能进行渲染树的构建（下一步）。因此，CSS 是<strong>渲染阻塞资源</strong>。优化 CSS 加载速度（内联关键 CSS、异步加载非关键 CSS）对首屏渲染性能至关重要。</li><li><strong>阻塞 JS：</strong> 在 CSSOM 构建完成前，后续的 JS 执行（如果 JS 试图访问尚未解析的 CSS 属性）可能会被阻塞。</li></ul></li></ul><h2 id="🌳-3-构建渲染树" tabindex="-1">🌳 3. 构建渲染树 <a class="header-anchor" href="#🌳-3-构建渲染树" aria-label="Permalink to “🌳 3.  构建渲染树”">​</a></h2><ul><li><strong>输入：</strong> DOM 树 + CSSOM 树。</li><li><strong>过程：</strong><ul><li>遍历 DOM 树中的每一个<strong>可见节点</strong>。</li><li>对于每个可见节点，在 CSSOM 树中找到匹配的样式规则，应用这些规则。</li><li>将带有最终计算样式的可见节点组合成另一棵树——<strong>渲染树</strong>。</li></ul></li><li><strong>关键点：</strong><ul><li><strong>仅包含可见内容：</strong> 渲染树只包含需要在屏幕上显示的元素。<code>display: none;</code> 的元素、<code>&lt;head&gt;</code>、<code>&lt;script&gt;</code> 等不会包含在内。<code>visibility: hidden;</code> 或 <code>opacity: 0;</code> 的元素会保留在渲染树中（占据空间）。</li><li><strong>每个节点包含视觉信息：</strong> 渲染树节点（通常称为渲染对象或渲染器）存储了元素的几何信息（位置、尺寸）和绘制指令。</li></ul></li></ul><h2 id="📐-4-布局" tabindex="-1">📐 4. 布局 <a class="header-anchor" href="#📐-4-布局" aria-label="Permalink to “📐 4.  布局”">​</a></h2><ul><li><strong>输入：</strong> 渲染树。</li><li><strong>过程：</strong><ul><li>计算渲染树中每个节点在<strong>视口</strong>内的精确位置（x, y 坐标）和尺寸（宽度、高度）。这个过程也称为 <strong>重排</strong>。</li><li>布局是一个递归过程：通常从根节点（<code>&lt;html&gt;</code>）开始，遍历整个渲染树，根据 CSS 的盒模型、定位（普通流、浮动、绝对/固定定位）、弹性/网格布局等规则计算所有节点的几何信息。</li><li>输出是一个包含所有节点位置和尺寸信息的“盒子模型”。</li></ul></li><li><strong>特点：</strong><ul><li><strong>相对单位转换：</strong> 将百分比、视口单位（vw/vh）等转换为屏幕上的实际像素值。</li><li><strong>成本高昂：</strong> 改变元素的几何属性（宽、高、位置、边距等）会触发整个或部分渲染树的重新布局（重排），这是影响性能的主要操作之一。</li></ul></li></ul><h2 id="🖌️-5-绘制" tabindex="-1">🖌️ 5. 绘制 <a class="header-anchor" href="#🖌️-5-绘制" aria-label="Permalink to “🖌️ 5.  绘制”">​</a></h2><ul><li><strong>输入：</strong> 布局后的渲染树。</li><li><strong>过程：</strong><ul><li>将渲染树分解成多个<strong>图层</strong>。某些元素（如 <code>transform</code>, <code>opacity</code>, <code>position: fixed</code>）会提升到独立的合成层（Compositing Layer）。</li><li>为每个图层生成<strong>绘制指令列表</strong>。这些指令描述了如何将元素的各个部分（背景、边框、文本、图片等）绘制到屏幕上的具体像素位置。这类似于画家的草图或指令集。</li><li>这个过程也称为<strong>光栅化</strong>的准备工作。绘制指令本身不直接操作像素。</li></ul></li><li><strong>特点：</strong><ul><li><strong>分层与合成：</strong> 分层使得浏览器可以对变化的部分进行高效的局部更新（只需重绘该层，然后与其他层合成）。这是现代浏览器实现流畅动画（如 transform, opacity）的关键。</li><li><strong>重绘：</strong> 改变元素的视觉属性但不影响布局（如颜色、背景图、阴影）只会触发<strong>重绘</strong>（Repaint），相对重排开销较小。</li></ul></li></ul><h2 id="🖥️-6-合成与显示" tabindex="-1">🖥️ 6. 合成与显示 <a class="header-anchor" href="#🖥️-6-合成与显示" aria-label="Permalink to “🖥️ 6.  合成与显示”">​</a></h2><ul><li><strong>输入：</strong> 各图层的绘制指令。</li><li><strong>过程：</strong><ol><li><strong>光栅化：</strong> 浏览器的主线程或专门的合成线程/进程（取决于浏览器架构）将绘制指令转换为屏幕上的实际像素点。这通常发生在<strong>图块</strong>中（将图层划分为小块）。</li><li><strong>合成：</strong> 合成线程将各个图层（尤其是独立合成层）的光栅化结果（图块）按照正确的顺序（z-index, 层叠上下文）和位置组合在一起。</li><li><strong>显示：</strong> 合成后的最终图像（帧）被传送到 GPU，最终显示在屏幕上。</li></ol></li><li><strong>特点：</strong><ul><li><strong>GPU 加速：</strong> 合成和最终的图像显示通常由 GPU 处理，速度非常快。</li><li><strong>独立线程：</strong> 现代浏览器将光栅化和合成工作放在与主线程（处理 JS、DOM、CSSOM、布局、绘制）不同的线程中，避免主线程繁忙（如 JS 执行）导致动画卡顿。</li></ul></li></ul><h2 id="📌-关键点总结" tabindex="-1">📌 关键点总结 <a class="header-anchor" href="#📌-关键点总结" aria-label="Permalink to “📌 关键点总结”">​</a></h2><ol><li><strong>渐进式处理：</strong> 浏览器尽力尽早显示内容，边下载、边解析、边渲染。</li><li><strong>阻塞资源：</strong><ul><li><strong>CSS 是渲染阻塞：</strong> 浏览器会等待 CSSOM 构建完成才开始构建渲染树和布局。</li><li><strong>JS 是解析器阻塞：</strong> 同步 JS (<code>&lt;script&gt;</code> 无 <code>async/defer</code>) 会阻塞 HTML 解析（从而阻塞 DOM 构建）和后续渲染。</li></ul></li><li><strong>渲染树是关键桥梁：</strong> 连接内容（DOM）和样式（CSSOM），只包含可见元素及其最终样式。</li><li><strong>布局（重排）代价高：</strong> 影响几何属性的更改会触发整个或部分流程的重新计算（回流），应尽量避免或优化。</li><li><strong>绘制（重绘）相对较轻：</strong> 只影响视觉样式不改变布局的操作只需重绘（可能还有合成）。</li><li><strong>合成效率高：</strong> 利用分层和 GPU 加速进行合成，是实现高性能动画（transform, opacity）的基础。</li><li><strong>事件循环：</strong> 整个渲染过程（以及 JS 执行）都是在浏览器的事件循环机制中调度执行的。渲染通常发生在事件循环的“渲染阶段”。</li></ol><h2 id="🚀-优化启示" tabindex="-1">🚀 优化启示 <a class="header-anchor" href="#🚀-优化启示" aria-label="Permalink to “🚀 优化启示”">​</a></h2><ul><li><strong>最小化阻塞：</strong><ul><li>使用 <code>async</code>/<code>defer</code> 加载非关键 JS。</li><li>内联关键 CSS，异步加载非关键 CSS。</li><li>避免在 <code>&lt;head&gt;</code> 中使用阻塞的 JS/CSS。</li></ul></li><li><strong>减少 DOM 复杂度：</strong> 保持 DOM 结构简洁，减少节点数量。</li><li><strong>高效 CSS 选择器：</strong> 避免过于复杂或低效的选择器（如深层嵌套、通配符 <code>*</code>）。</li><li><strong>优化 JS 执行：</strong> 避免长任务，使用 <code>requestAnimationFrame</code> 进行视觉变更。</li><li><strong>减少重排/重绘：</strong><ul><li>批量 DOM 读写（使用虚拟 DOM 库或 <code>DocumentFragment</code>）。</li><li>避免在循环中操作样式。</li><li>使用 CSS <code>transform</code> 和 <code>opacity</code> 进行动画（利用合成层）。</li><li>避免频繁读取会触发重排的属性（如 <code>offsetTop</code>, <code>scrollTop</code>, <code>getComputedStyle</code>）。</li></ul></li><li><strong>利用合成层：</strong> 对动画元素使用 <code>will-change: transform;</code> 或 <code>transform: translateZ(0);</code> 谨慎提升为合成层（有内存开销）。</li></ul><p>理解这个流程对于诊断页面性能问题（使用浏览器 DevTools 的 Performance 面板）和进行有效的性能优化至关重要。</p>`,19)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};