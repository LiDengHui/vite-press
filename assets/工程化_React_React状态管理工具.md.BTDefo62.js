import{_ as i,c as a,o as t,a3 as n}from"./chunks/framework.D-BI-jj5.js";const o=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"工程化/React/React状态管理工具.md","filePath":"工程化/React/React状态管理工具.md","lastUpdated":1749215922000}'),l={name:"工程化/React/React状态管理工具.md"};function h(k,s,e,r,p,d){return t(),a("div",null,s[0]||(s[0]=[n(`<p>React 状态管理工具丰富多样，各有其设计哲学和适用场景。以下从<strong>核心思想、代表工具、优缺点及使用建议</strong>四方面系统梳理，帮助你精准选型：</p><hr><h3 id="🔄-一、react-原生方案" tabindex="-1">🔄 <strong>一、React 原生方案</strong> <a class="header-anchor" href="#🔄-一、react-原生方案" aria-label="Permalink to “🔄 一、React 原生方案”">​</a></h3><h4 id="_1-usestate-usereducer" tabindex="-1">1. <strong>useState/useReducer</strong> <a class="header-anchor" href="#_1-usestate-usereducer" aria-label="Permalink to “1. useState/useReducer”">​</a></h4><ul><li><strong>核心</strong>：组件内部状态管理，<code>useReducer</code> 适合复杂状态逻辑。</li><li><strong>优点</strong>：零依赖、轻量、符合 React 函数式思维。</li><li><strong>缺点</strong>：状态无法跨组件共享，需手动通过 props 透传（“prop drilling”）。</li><li><strong>适用场景</strong>：组件内部状态（如表单控制、UI 交互状态）。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Reducer 函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> todoReducer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (action.type) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;ADD_TODO&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state, { id: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), text: action.text, completed: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;TOGGLE_TODO&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">todo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (todo.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">todo, completed: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">todo.completed } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> todo));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;DELETE_TODO&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">todo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> todo.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action.id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在组件中使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">todos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useReducer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(todoReducer, []);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加任务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ADD_TODO&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, text: newTodo });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 切换完成状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TOGGLE_TODO&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, id: todo.id });</span></span></code></pre></div><h4 id="_2-context-api" tabindex="-1">2. <strong>Context API</strong> <a class="header-anchor" href="#_2-context-api" aria-label="Permalink to “2. Context API”">​</a></h4><ul><li><strong>核心</strong>：跨层级状态共享，通过 <code>Provider</code> 注入全局状态。</li><li><strong>优点</strong>：内置支持、免去 props 透传。</li><li><strong>缺点</strong>： <ul><li>任何 <code>Context</code> 值变更会触发<strong>所有消费者组件重渲染</strong>，性能敏感场景需配合 <code>memo</code> 优化。</li><li>复杂数据流管理能力弱，易导致代码混乱。</li></ul></li><li><strong>适用场景</strong>：主题切换、用户身份等低频变更的全局状态。</li></ul><hr><h3 id="🧩-二、原子状态管理-细粒度更新" tabindex="-1">🧩 <strong>二、原子状态管理（细粒度更新）</strong> <a class="header-anchor" href="#🧩-二、原子状态管理-细粒度更新" aria-label="Permalink to “🧩 二、原子状态管理（细粒度更新）”">​</a></h3><h4 id="_1-jotai" tabindex="-1">1. <strong>Jotai</strong> <a class="header-anchor" href="#_1-jotai" aria-label="Permalink to “1. Jotai”">​</a></h4><ul><li><strong>核心</strong>：基于原子（atom）的 primitive 状态单元，组合式更新。</li><li><strong>优点</strong>： <ul><li>API 极简（类似 <code>useState</code>），学习成本低。</li><li><strong>按需渲染</strong>，仅更新依赖变更的组件，性能优异。</li></ul></li><li><strong>缺点</strong>：强依赖 React 上下文，无法在非 React 环境使用。</li><li><strong>代码示例</strong>：<div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { atom, useAtom } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;jotai&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> countAtom</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> atom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useAtom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(countAtom);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;{count}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><h4 id="_2-recoil" tabindex="-1">2. <strong>Recoil</strong> <a class="header-anchor" href="#_2-recoil" aria-label="Permalink to “2. Recoil”">​</a></h4><ul><li><strong>核心</strong>：类似 Jotai，但提供更丰富的 API（如异步 Selector、状态快照）。</li><li><strong>优点</strong>：支持派生状态（computed values）、状态依赖图可视化。</li><li><strong>缺点</strong>：体积较大，API 复杂度高于 Jotai。</li><li><strong>适用场景</strong>：需要复杂状态衍生逻辑（如过滤列表）或调试工具支持的项目。</li></ul><hr><h3 id="🏗-三、flux-redux-架构衍生" tabindex="-1">🏗 <strong>三、Flux/Redux 架构衍生</strong> <a class="header-anchor" href="#🏗-三、flux-redux-架构衍生" aria-label="Permalink to “🏗 三、Flux/Redux 架构衍生”">​</a></h3><h4 id="_1-redux-react-redux" tabindex="-1">1. <strong>Redux (+ React-Redux)</strong> <a class="header-anchor" href="#_1-redux-react-redux" aria-label="Permalink to “1. Redux (+ React-Redux)”">​</a></h4><ul><li><strong>核心</strong>：单向数据流（Action → Reducer → Store），强调不可变性和纯函数。</li><li><strong>优点</strong>： <ul><li>时间旅行调试、中间件生态（Redux-Thunk/Saga）。</li><li>框架无关，适合大型项目规范化协作。</li></ul></li><li><strong>缺点</strong>：模板代码多（Action/Reducer/Store 定义繁琐），心智负担重。</li><li><strong>演进</strong>：现代 Redux 已简化（<code>@reduxjs/toolkit</code> 减少样板代码）。</li></ul><h4 id="_2-zustand" tabindex="-1">2. <strong>Zustand</strong> <a class="header-anchor" href="#_2-zustand" aria-label="Permalink to “2. Zustand”">​</a></h4><ul><li><strong>核心</strong>：轻量 Redux 替代品，Store 即 Hook，无 Provider 包裹。</li><li><strong>优点</strong>： <ul><li><strong>API 简洁</strong>：免去 Action/Reducer 定义，直接修改状态。</li><li>支持中间件（持久化、日志等），<strong>组件外可调用</strong>。</li></ul></li><li><strong>缺点</strong>：原生不支持计算属性（需配合 <code>zustand-computed</code> 或手动派生）。</li><li><strong>代码示例</strong>：<div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> create </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;zustand&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> useStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  bears: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addBear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ bears: state.bears </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件内使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bears</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.bears);</span></span></code></pre></div></li></ul><hr><h3 id="⚡-四、响应式-mutable-流派" tabindex="-1">⚡ <strong>四、响应式/Mutable 流派</strong> <a class="header-anchor" href="#⚡-四、响应式-mutable-流派" aria-label="Permalink to “⚡ 四、响应式/Mutable 流派”">​</a></h3><h4 id="_1-mobx" tabindex="-1">1. <strong>MobX</strong> <a class="header-anchor" href="#_1-mobx" aria-label="Permalink to “1. MobX”">​</a></h4><ul><li><strong>核心</strong>：通过 <code>@observable</code> 自动追踪状态依赖，变更触发精准更新。</li><li><strong>优点</strong>： <ul><li><strong>代码直观</strong>：直接赋值更新状态（<code>state.count++</code>）。</li><li>自动处理衍生数据（<code>@computed</code>）。</li></ul></li><li><strong>缺点</strong>： <ul><li>响应式模式与 React 的 Immutable 范式冲突，调试可能反直觉。</li><li>体积较大（约 4KB）。</li></ul></li><li><strong>适用场景</strong>：Vue 转 React 开发者或追求开发速度的项目。</li></ul><h4 id="_2-valtio" tabindex="-1">2. <strong>Valtio</strong> <a class="header-anchor" href="#_2-valtio" aria-label="Permalink to “2. Valtio”">​</a></h4><ul><li><strong>核心</strong>：Proxy 实现轻量响应式，类似 MobX 但更简洁。</li><li><strong>优点</strong>：API 极简（<code>proxy</code> + <code>useSnapshot</code>），<strong>无装饰器语法</strong>。</li><li><strong>缺点</strong>：可变模型可能引发意外副作用，社区生态较小。</li><li><strong>代码示例</strong>：<div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { proxy, useSnapshot } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;valtio&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> snap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSnapshot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&gt;{snap.count}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><h4 id="_3-hookstate" tabindex="-1">3. <strong>Hookstate</strong> <a class="header-anchor" href="#_3-hookstate" aria-label="Permalink to “3. Hookstate”">​</a></h4><ul><li><strong>核心</strong>：融合原子化与响应式，支持嵌套状态一键更新。</li><li><strong>优点</strong>： <ul><li><strong>高性能</strong>：局部更新避免全量重渲染。</li><li>同时支持本地/全局状态，Next.js 友好。</li></ul></li><li><strong>缺点</strong>：社区成熟度低于主流工具。</li><li><strong>代码示例</strong>：<div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useHookstate } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@hookstate/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useHookstate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.count.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;{state.count.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul><hr><h3 id="📊-主流工具关键对比" tabindex="-1">📊 <strong>主流工具关键对比</strong> <a class="header-anchor" href="#📊-主流工具关键对比" aria-label="Permalink to “📊 主流工具关键对比”">​</a></h3><table tabindex="0"><thead><tr><th><strong>工具</strong></th><th><strong>学习曲线</strong></th><th><strong>性能</strong></th><th><strong>TS 支持</strong></th><th><strong>包大小</strong></th><th><strong>状态模型</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Context</strong></td><td>低</td><td>差</td><td>优秀</td><td>0 KB</td><td>不可变</td><td>简单全局状态</td></tr><tr><td><strong>Jotai</strong></td><td>低</td><td>优秀</td><td>优秀</td><td>~3 KB</td><td>原子不可变</td><td>细粒度更新</td></tr><tr><td><strong>Zustand</strong></td><td>中</td><td>优秀</td><td>优秀</td><td>~1 KB</td><td>不可变</td><td>轻量 Redux 替代</td></tr><tr><td><strong>MobX</strong></td><td>中高</td><td>优秀</td><td>优秀</td><td>~15 KB</td><td>响应式可变</td><td>复杂对象模型</td></tr><tr><td><strong>Valtio</strong></td><td>低</td><td>优秀</td><td>优秀</td><td>~4 KB</td><td>响应式可变</td><td>快速原型开发</td></tr><tr><td><strong>Redux</strong></td><td>高</td><td>中</td><td>优秀</td><td>~10 KB</td><td>不可变</td><td>大型团队规范项目</td></tr></tbody></table><hr><h3 id="🧭-选型建议" tabindex="-1">🧭 <strong>选型建议</strong> <a class="header-anchor" href="#🧭-选型建议" aria-label="Permalink to “🧭 选型建议”">​</a></h3><ol><li><p><strong>小型应用/组件状态</strong>：</p><ul><li>首选 <code>useState/useReducer</code>，需要跨组件共享时用 <strong>Context</strong>。</li></ul></li><li><p><strong>中型应用（全局状态）</strong>：</p><ul><li>追求简洁 → <strong>Zustand</strong>（不可变）或 <strong>Valtio</strong>（可变）。</li><li>需细粒度更新 → <strong>Jotai</strong>。</li></ul></li><li><p><strong>大型复杂应用</strong>：</p><ul><li>强规范团队 → <strong>Redux + RTK</strong>（利用中间件生态）。</li><li>复杂领域模型 → <strong>MobX</strong>（自动依赖追踪更高效）。</li></ul></li><li><p><strong>特殊需求</strong>：</p><ul><li>Next.js 集成 → <strong>Hookstate</strong> 或 <strong>Zustand</strong>。</li><li>状态持久化/撤销 → <strong>Redux</strong> 或 <strong>Zustand + 中间件</strong>。</li></ul></li></ol><blockquote><p>💡 <strong>避坑提示</strong>：</p><ul><li>避免在 Context 中存储高频变更数据（如实时坐标），会触发全子树重渲染。</li><li>MobX/Valtio 可变模型虽便捷，但需警惕<strong>直接修改状态导致的不可预测性</strong>，建议配合 Immer 使用。</li></ul></blockquote><hr><h3 id="💎-总结" tabindex="-1">💎 <strong>总结</strong> <a class="header-anchor" href="#💎-总结" aria-label="Permalink to “💎 总结”">​</a></h3><p>React 状态管理的本质是<strong>平衡开发效率、性能与可维护性</strong>。2024 年趋势更倾向轻量原子库（Jotai/Zustand）和响应式工具（Valtio），Redux 仍是大团队基石。选型时需考量：</p><ol><li><strong>团队熟悉度</strong>：Redux 需投入学习，Zustand/Jotai 更易上手。</li><li><strong>状态结构</strong>：扁平数据用原子库，嵌套对象用响应式。</li><li><strong>渲染性能</strong>：原子库和响应式工具在频繁更新场景更具优势。</li></ol><p>实际项目中可组合使用，如 <strong>Zustand 管理全局 + Jotai 处理局部细粒度状态</strong>，兼顾灵活与性能。</p>`,40)]))}const E=i(l,[["render",h]]);export{o as __pageData,E as default};
