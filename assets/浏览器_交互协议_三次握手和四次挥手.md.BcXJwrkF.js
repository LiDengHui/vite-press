import{_ as C,I as a,c as g,o,j as l,b as t,a7 as r,a as i,w as A,J as n,a9 as s}from"./chunks/framework.DGe06YP7.js";const p=JSON.parse('{"title":"三次握手和四次挥手","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/交互协议/三次握手和四次挥手.md","filePath":"浏览器/交互协议/三次握手和四次挥手.md","lastUpdated":null}'),S={name:"浏览器/交互协议/三次握手和四次挥手.md"};function d(B,e,c,N,_,I){const E=a("Mermaid");return o(),g("div",null,[e[2]||(e[2]=l("h1",{id:"三次握手和四次挥手",tabindex:"-1"},[i("三次握手和四次挥手 "),l("a",{class:"header-anchor",href:"#三次握手和四次挥手","aria-label":"Permalink to “三次握手和四次挥手”"},"​")],-1)),e[3]||(e[3]=l("p",null,[i("TCP（传输控制协议）使用 "),l("strong",null,"三次握手（Three-way Handshake）"),i(" 建立连接，使用 "),l("strong",null,"四次挥手（Four-way Handshake）"),i(" 终止连接。这是保证可靠、面向连接通信的核心机制。")],-1)),e[4]||(e[4]=l("h2",{id:"一、三次握手-建立连接",tabindex:"-1"},[i("一、三次握手（建立连接） "),l("a",{class:"header-anchor",href:"#一、三次握手-建立连接","aria-label":"Permalink to “一、三次握手（建立连接）”"},"​")],-1)),(o(),t(s,null,{default:A(()=>[n(E,{id:"mermaid-9",class:"mermaid my-class main img",graph:"sequenceDiagram%0A%20%20%20%20participant%20Client%20as%20%E5%AE%A2%E6%88%B7%E7%AB%AF%0A%20%20%20%20participant%20Service%20as%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%0A%20%20%20%20Client%20-%3E%3E%20Service%3A%201.%20SYN%20%E6%8A%A5%E6%96%87%EF%BC%88SYN%3D1%EF%BC%89%2CClient_ISN%0A%20%20%20%20Note%20over%20Client%3A%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%20SYN_SENT%20%E7%8A%B6%E6%80%81%0A%20%20%20%20Service%20-%3E%3E%20Client%3A%202.%20SYN%2BACK%20%E6%8A%A5%E6%96%87%EF%BC%88SYN%3D1%2C%20ACK%3D1)%2C%E7%A1%AE%E8%AE%A4%E5%8F%B7%20Client_ISN%20%2B1%20%2C%20Server_ISN%0A%20%20%20%20Note%20over%20Service%3A%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E5%85%A5%20SYN_RECEIVED%20%E7%8A%B6%E6%80%81%0A%20%20%20%20Client%20-%3E%3E%20Service%3A%203.%20ACK%20%E6%8A%A5%E6%96%87%EF%BC%88ACK%3D1)%EF%BC%8C%20%E7%A1%AE%E8%AE%A4%E5%8F%B7%20Server_ISN%20%2B%201%2C%20%E5%BA%8F%E5%88%97%E5%8F%B7%20Client_ISN%20%2B%201%0A%20%20%20%20Note%20over%20Client%2C%20Service%3A%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%20ESTABLISHED%20%E7%8A%B6%E6%80%81%2C%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E5%85%A5%20ESTABLISHED%20%E7%8A%B6%E6%80%81%0A%0A"})]),fallback:A(()=>e[0]||(e[0]=[i(" Loading... ")])),_:1})),e[5]||(e[5]=r("<p>目的：确保<strong>双方都具有发送和接收数据的能力</strong>，并同步初始序列号（Sequence Number）。</p><ol><li><p><strong>第一次握手（SYN）：</strong></p><ul><li>客户端发送一个 TCP 报文段给服务器。</li><li>设置 <strong>SYN 标志位为 1</strong>（表示这是一个连接请求）。</li><li>选择一个<strong>初始序列号（Client_ISN）</strong>（通常是随机数）。</li><li>客户端进入 <code>SYN_SENT</code> 状态。</li></ul></li><li><p><strong>第二次握手（SYN + ACK）：</strong></p><ul><li>服务器收到客户端的 SYN 报文。</li><li>如果同意建立连接，则发送一个 TCP 报文段给客户端。</li><li>设置 <strong>SYN 标志位为 1</strong>（表示这也是一个连接请求）。</li><li>设置 <strong>ACK 标志位为 1</strong>（表示确认）。</li><li><strong>确认号（Acknowledgment Number）</strong> 设置为 <code>Client_ISN + 1</code>（表示期望收到客户端的下一个字节的序号是这个值）。</li><li>选择一个自己的<strong>初始序列号（Server_ISN）</strong>（通常是随机数）。</li><li>服务器进入 <code>SYN_RECEIVED</code> 状态。</li></ul></li><li><p><strong>第三次握手（ACK）：</strong></p><ul><li>客户端收到服务器的 SYN+ACK 报文。</li><li>客户端发送一个 TCP 报文段给服务器。</li><li>设置 <strong>ACK 标志位为 1</strong>（表示确认）。</li><li><strong>确认号（Acknowledgment Number）</strong> 设置为 <code>Server_ISN + 1</code>（表示期望收到服务器的下一个字节的序号是这个值）。</li><li>（此时可以携带应用层数据）序列号为 <code>Client_ISN + 1</code>（因为第一次握手的 SYN 消耗了一个序号）。</li><li>客户端进入 <code>ESTABLISHED</code> 状态。</li><li>服务器收到 ACK 后，也进入 <code>ESTABLISHED</code> 状态。</li></ul></li></ol><p><strong>为什么需要三次？</strong></p><ul><li><strong>防止旧的重复连接初始化请求造成混乱：</strong> 主要是为了防止在网络延迟的情况下，一个早已失效的连接请求报文突然又传到了服务器，导致服务器错误地打开连接（历史连接问题）。第三次握手让客户端有机会确认这个连接请求是否是当前最新的、有效的请求。</li><li><strong>确保双方初始序列号同步：</strong> 第一次握手告知 Client_ISN，第二次握手确认 Client_ISN 并告知 Server_ISN，第三次握手确认 Server_ISN。只有双方都确认了对方的初始序列号，才能保证后续数据包传输的有序性。</li><li><strong>验证双向通信能力：</strong> 第一次握手证明客户端能发送到服务器；第二次握手证明服务器能接收（收到第一次）并能发送到客户端；第三次握手证明客户端能接收（收到第二次）并能发送到服务器。</li></ul>",4)),(o(),t(s,null,{default:A(()=>[n(E,{id:"mermaid-146",class:"mermaid my-class main img",graph:"sequenceDiagram%0A%20%20%20%20participant%20Client%20as%20%E5%AE%A2%E6%88%B7%E7%AB%AF%0A%20%20%20%20participant%20Service%20as%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%0A%20%20%20%20Client%20-%3E%3E%20Service%3A%201.%20FIN%20%E6%8A%A5%E6%96%87%EF%BC%88FIN%3D1%EF%BC%89%2CClient_ISN%0A%20%20%20%20Note%20over%20Client%3A%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%20FIN_WAIT_1%20%E7%8A%B6%E6%80%81%0A%20%20%20%20Service%20-%3E%3E%20Client%3A%202.%20ACK%20%E6%8A%A5%E6%96%87%EF%BC%88ACK%3D1)%2C%E7%A1%AE%E8%AE%A4%E5%8F%B7%20Client_ISN%20%2B1%2C%20Server_ISN%0A%20%20%20%20Note%20over%20Client%2C%20Service%3A%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%20FIN_WAIT_2%20%E7%8A%B6%E6%80%81%2C%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E5%85%A5%20CLOSE_WAIT%20%E7%8A%B6%E6%80%81%0A%20%20%20%20Service%20-%3E%3E%20Client%3A%203.%20FIN%20%E6%8A%A5%E6%96%87%EF%BC%88FIN%3D1%EF%BC%89%2CClient_ISN%0A%20%20%20%20Note%20over%20Service%3A%20LAST_ACK%20%E7%8A%B6%E6%80%81%0A%20%20%20%20Client-%3E%3E%20Service%3A%204.%20ACK%20%E6%8A%A5%E6%96%87%EF%BC%88ACK%3D1)%EF%BC%8C%20%E7%A1%AE%E8%AE%A4%E5%8F%B7%20Client_ISN%20%2B%201%2C%20%E5%BA%8F%E5%88%97%E5%8F%B7%20Server_ISN%20%2B%201%0A%20%20%20%20Note%20over%20Client%2C%20Service%3A%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5%20TIME_WAIT%20%E7%8A%B6%E6%80%81%2C%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E5%85%A5%20CLOSED%20%E7%8A%B6%E6%80%81%0A%20%20%20%20Note%20over%20Client%3A%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E5%85%A5CLOSED%20%E7%8A%B6%E6%80%81%20%20%20%20%0A"})]),fallback:A(()=>e[1]||(e[1]=[i(" Loading... ")])),_:1})),e[6]||(e[6]=r('<h2 id="二、四次挥手-终止连接" tabindex="-1">二、四次挥手（终止连接） <a class="header-anchor" href="#二、四次挥手-终止连接" aria-label="Permalink to “二、四次挥手（终止连接）”">​</a></h2><p>目的：<strong>双方都确认数据发送完毕</strong>，并安全、有序地关闭连接。TCP 连接是全双工的，每个方向必须独立关闭。</p><ol><li><p><strong>第一次挥手（FIN）：</strong></p><ul><li>主动关闭方（可以是客户端或服务器，假设是客户端）发送一个 TCP 报文段。</li><li>设置 <strong>FIN 标志位为 1</strong>（表示它已经没有数据要发送了）。</li><li>指定一个序列号（假设为 <code>Seq = u</code>），这个序列号等于它已传送数据的最后一个字节的序号加 1。</li><li>客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ul></li><li><p><strong>第二次挥手（ACK）：</strong></p><ul><li>被动关闭方（服务器）收到 FIN 报文。</li><li>发送一个 ACK 确认报文。</li><li>设置 <strong>ACK 标志位为 1</strong>。</li><li><strong>确认号（Acknowledgment Number）</strong> 设置为 <code>u + 1</code>（表示期望收到主动关闭方的下一个字节的序号是这个值）。</li><li>（此时，服务器可能还有数据要发送给客户端）。</li><li>服务器进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到这个 ACK 后，进入 <code>FIN_WAIT_2</code> 状态（等待服务器的 FIN 报文）。</li></ul></li><li><p><strong>第三次挥手（FIN）：</strong></p><ul><li>被动关闭方（服务器）完成了它所有数据的发送。</li><li>服务器发送一个 FIN 报文给主动关闭方（客户端）。</li><li>设置 <strong>FIN 标志位为 1</strong>。</li><li>指定一个序列号（假设为 <code>Seq = w</code>），这个序列号等于它已传送数据的最后一个字节的序号加 1（可能包含在第二次挥手之后发送的数据）。</li><li>服务器进入 <code>LAST_ACK</code> 状态（等待最后一个 ACK）。</li></ul></li><li><p><strong>第四次挥手（ACK）：</strong></p><ul><li>主动关闭方（客户端）收到服务器的 FIN 报文。</li><li>客户端发送一个 ACK 确认报文。</li><li>设置 <strong>ACK 标志位为 1</strong>。</li><li><strong>确认号（Acknowledgment Number）</strong> 设置为 <code>w + 1</code>。</li><li>客户端进入 <code>TIME_WAIT</code> 状态（也称为 <code>2MSL</code> 等待状态）。</li><li>服务器收到这个 ACK 后，进入 <code>CLOSED</code> 状态（连接关闭）。</li><li>客户端在 <code>TIME_WAIT</code> 状态等待 <strong>2MSL（Maximum Segment Lifetime，报文最大生存时间，通常 1-4 分钟）</strong> 后，也进入 <code>CLOSED</code> 状态。</li></ul></li></ol><p><strong>为什么需要四次？</strong> 因为 TCP 连接是全双工的：</p><ul><li>第一次挥手（FIN）表示“<strong>我（主动方）没有数据要发给你了</strong>”。</li><li>第二次挥手（ACK）表示“<strong>我知道你没数据发给我了</strong>”（此时被动方可能还有数据要发给主动方）。</li><li>第三次挥手（FIN）表示“<strong>我（被动方）也没有数据要发给你了</strong>”。</li><li>第四次挥手（ACK）表示“<strong>我知道你也没数据发给我了</strong>”，最终确认关闭。</li></ul><p><strong>为什么主动关闭方需要 TIME_WAIT 状态？</strong></p><ol><li><strong>确保最后一个 ACK 可靠到达：</strong> 如果这个 ACK 丢失，被动关闭方（处于 <code>LAST_ACK</code>）会超时重传 FIN。主动关闭方在 <code>TIME_WAIT</code> 状态下收到重传的 FIN 后，会重新发送 ACK 并重置 <code>TIME_WAIT</code> 计时器。</li><li><strong>让旧连接的重复报文在网络中消逝：</strong> 等待 2MSL 时间，确保本次连接中产生的所有报文都已在网络中消失，不会干扰后续使用相同 IP 地址和端口号建立的新连接。</li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h3><ul><li><strong>三次握手：</strong> SYN -&gt; SYN+ACK -&gt; ACK。<strong>建立连接</strong>，确认双方通信能力和初始序列号。</li><li><strong>四次挥手：</strong> FIN -&gt; ACK -&gt; FIN -&gt; ACK。<strong>终止连接</strong>，双方独立确认数据发送完毕并关闭各自方向的通道。</li></ul><p>这两个过程是 TCP 协议实现可靠传输、面向连接特性的基石。理解它们对于诊断网络问题和学习网络协议栈至关重要。</p>',10))])}const T=C(S,[["render",d]]);export{p as __pageData,T as default};
