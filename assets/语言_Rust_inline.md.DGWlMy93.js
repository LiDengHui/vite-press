import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.Cyk5UgWo.js";const i=JSON.parse(`{"title":"inline","description":"","frontmatter":{},"headers":[],"relativePath":"语言/Rust/inline.md","filePath":"语言/Rust/inline.md","lastUpdated":1750738239000}`),a={name:`语言/Rust/inline.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="inline" tabindex="-1">inline <a class="header-anchor" href="#inline" aria-label="Permalink to “inline”">​</a></h1><p>In Rust, the #[inline] attribute is a hint to the compiler that suggests inserting the function&#39;s code directly at the call site (inline expansion) rather than performing a regular function call. This is typically used for:</p><p>Small, frequently called functions where the overhead of a function call would be significant Generic functions that need to be instantiated for multiple types Cases where inlining enables further optimizations In this specific generated visitor code from SWC (Speedy Web Compiler), the #[inline] attribute is used extensively because:</p><p>These visitor methods are called recursively during AST traversal The compiler needs to handle many different node types efficiently The code is generated automatically and needs to be highly optimized The compiler may still choose to ignore the hint based on its optimization heuristics, but in practice this attribute helps reduce function call overhead in the hot paths of the compiler&#39;s AST processing.</p><p>For the specific call expression visitor shown:</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[inline]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> visit_mut_call_expr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;mut</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;mut</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CallExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CallExpr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VisitMutWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">visit_mut_children_with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The inline hint helps ensure that visiting each CallExpr node in the AST doesn&#39;t incur unnecessary function call overhead, which is critical for compiler performance.</p>`,7)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};