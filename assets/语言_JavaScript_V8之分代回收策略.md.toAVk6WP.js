import{_ as r,c as t,o as n,a7 as e}from"./chunks/framework.CegclTe-.js";const S=JSON.parse('{"title":"V8 之分代回收策略","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/V8之分代回收策略.md","filePath":"语言/JavaScript/V8之分代回收策略.md","lastUpdated":1750738239000}'),s={name:"语言/JavaScript/V8之分代回收策略.md"};function l(a,o,i,g,c,d){return n(),t("div",null,o[0]||(o[0]=[e('<h1 id="v8-之分代回收策略" tabindex="-1">V8 之分代回收策略 <a class="header-anchor" href="#v8-之分代回收策略" aria-label="Permalink to “V8 之分代回收策略”">​</a></h1><p>V8 引擎（以及其他现代垃圾回收器）采用<strong>分代垃圾回收策略</strong>，其核心思想基于一个观察：<strong>在大多数程序中，绝大多数对象都是“朝生夕死”的</strong>（生命周期很短），只有少数对象会存活较长时间。</p><p>这个观察被称为<strong>弱分代假说</strong>。分代回收策略就是利用这一特点，将堆内存划分为不同的“代”，并对不同代采用不同的、更高效的垃圾回收算法，从而显著减少垃圾回收的总体开销和停顿时间。</p><h2 id="v8-分代回收的核心机制" tabindex="-1">V8 分代回收的核心机制 <a class="header-anchor" href="#v8-分代回收的核心机制" aria-label="Permalink to “V8 分代回收的核心机制”">​</a></h2><ol><li><p><strong>代际划分：</strong></p><ul><li><strong>新生代：</strong> 新创建的对象首先被分配在这里。新生代区域相对较小（通常在 1MB 到 8MB 之间）。这个区域的对象生命周期极短，大部分很快变得不可达。</li><li><strong>老生代：</strong> 在新生代中经历过一定次数垃圾回收后仍然存活下来的对象，会被<strong>晋升</strong>到老生代。老生代区域要大得多（可达几百 MB 甚至 GB），存放生命周期较长的对象。老生代中也包含一些直接分配的大对象（避免在新生代中复制）。</li></ul></li><li><p><strong>针对不同代的回收策略：</strong></p><ul><li><p><strong>新生代回收 (Minor GC / Scavenge)：</strong></p><ul><li><strong>算法：</strong> 主要采用 <strong>Scavenge 算法</strong>（一种<strong>Cheney算法</strong>的实现），这是一种<strong>复制算法</strong>。</li><li><strong>过程：</strong><ol><li>将新生代空间等分为两块：<strong><code>From-Space</code></strong> (活动区/对象区) 和 <strong><code>To-Space</code></strong> (空闲区/空闲区)。</li><li>新对象只分配在 <code>From-Space</code>。</li><li>当 <code>From-Space</code> 快满时，触发一次 Minor GC。</li><li>垃圾回收器从根对象（全局变量、活动函数栈上的变量等）开始扫描，标记所有在 <code>From-Space</code> 中<strong>可达</strong>的对象。</li><li>将标记为可达的对象<strong>复制</strong>到 <code>To-Space</code> 中，并紧密排列（消除内存碎片）。</li><li>复制完成后，清除整个 <code>From-Space</code>（因为剩下的都是不可达的垃圾）。</li><li>交换 <code>From-Space</code> 和 <code>To-Space</code> 的角色。原来的 <code>To-Space</code> 变为新的 <code>From-Space</code>（用于新对象分配），原来的 <code>From-Space</code> 变为新的空闲 <code>To-Space</code>。</li></ol></li><li><strong>特点：</strong> 速度非常快（只处理活动对象，不处理死对象；操作在连续空间内进行，效率高），停顿时间短。但空间利用率只有 50%（因为需要一半空间作为空闲区）。适用于频繁回收大量短命对象的场景。</li><li><strong>对象晋升：</strong> 如果一个对象在新生代中经历了一次 Minor GC 后仍然存活，或者 <code>To-Space</code> 空间不足以容纳所有要复制的存活对象，那么这个对象会被<strong>晋升</strong>到老生代。</li></ul></li><li><p><strong>老生代回收 (Major GC / Full GC)：</strong></p><ul><li><strong>算法：</strong> 主要采用 <strong>标记-清除 (Mark-Sweep)</strong> 和 <strong>标记-整理 (Mark-Compact)</strong> 的组合。通常增量标记、并发标记/清除等优化技术会应用在这里以减少停顿。</li><li><strong>过程：</strong><ol><li><strong>标记阶段：</strong> 从根对象开始，递归遍历对象图，标记所有<strong>可达</strong>的老生代对象。</li><li><strong>清除阶段 (Mark-Sweep)：</strong> 遍历整个老生代堆，回收所有<strong>未被标记</strong>的对象所占用的内存。回收后内存空间是<strong>不连续</strong>的（有碎片）。</li><li><strong>整理阶段 (Mark-Compact - 可选)：</strong> 为了解决 Mark-Sweep 产生的碎片问题，V8 有时（当碎片达到一定程度时）会在 Mark-Sweep 之后或代替 Mark-Sweep 进行 Mark-Compact。它会将所有存活的对象<strong>移动</strong>到堆的一端，紧密排列，然后清理掉边界外的所有空间。这样回收的空间是连续的。</li></ol></li><li><strong>特点：</strong> 回收整个老生代，速度相对较慢（对象多、存活率高、对象图复杂），停顿时间长（但通过增量标记、并发回收等优化可以显著减少感知停顿）。空间利用率高（Mark-Compact 后无碎片）。适用于回收生命周期长的对象和低频回收。</li></ul></li></ul></li><li><p><strong>代际引用与写屏障：</strong></p><ul><li><strong>问题：</strong> 分代策略的一个关键挑战是<strong>代际引用</strong>。老生代中的对象可能持有指向新生代对象的引用。如果只扫描新生代本身，那么一个被老生代对象引用的新生代对象会被认为是可达的（即使它本应在新生代回收中被回收），反之，如果只回收老生代，可能漏掉仅被新生代引用的老生代对象（但这种情况较少）。</li><li><strong>解决方案：写屏障：</strong><ul><li>V8 引入了一种称为<strong>写屏障</strong>的机制。当 JavaScript 代码<strong>写入</strong>一个对象的属性（即修改引用关系）时，V8 会检查： <ol><li>被写入属性的对象是否位于<strong>老生代</strong>。</li><li>被赋值的新值是否是一个<strong>新生代</strong>中的对象。</li></ol></li><li>如果以上两个条件都满足，V8 会将这个老生代对象记录下来（例如，将其加入一个特殊的“<code>store buffer</code>”或“<code>card table</code>”）。</li></ul></li><li><strong>作用：</strong> 在 Minor GC 进行可达性扫描时，除了扫描新生代内部的引用和根对象，<strong>还需要将记录了的老生代对象（通过写屏障记录的）作为额外的根</strong>来扫描。这确保了即使新生代对象只被老生代引用，也不会在 Minor GC 中被错误回收。这解决了“老生代引用新生代”的问题，保证了新生代回收的正确性。老生代回收通常需要扫描整个堆（包括新生代），或者利用类似机制处理反向引用。</li></ul></li></ol><h2 id="分代回收的优势" tabindex="-1">分代回收的优势 <a class="header-anchor" href="#分代回收的优势" aria-label="Permalink to “分代回收的优势”">​</a></h2><ol><li><strong>提高吞吐量：</strong> 大部分短命对象在快速高效的新生代回收中被回收，避免了在老生代上执行昂贵的回收操作。</li><li><strong>减少停顿时间：</strong> Minor GC 速度非常快，停顿时间很短。虽然 Major GC 停顿较长，但发生的频率远低于 Minor GC（因为老生代对象存活率高，变化慢）。优化技术（增量标记、并发回收）主要应用在 Major GC 上进一步降低停顿。</li><li><strong>空间局部性：</strong> Scavenge 算法通过复制整理存活对象，使它们紧密排列在连续的内存中，提高了 CPU 缓存命中率。标记-整理也有类似效果。</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><p>V8 的分代垃圾回收策略是其高性能的关键之一。它通过将堆划分为新生代和老生代，并针对不同代对象的生存特点采用不同的回收算法（Scavenge 用于新生代，Mark-Sweep/Mark-Compact 用于老生代），显著提高了垃圾回收的效率，减少了应用停顿时间。写屏障机制的引入巧妙地解决了代际引用带来的正确性问题，使得分代策略能够安全高效地运行。</p>',9)]))}const _=r(s,[["render",l]]);export{S as __pageData,_ as default};
