import{_ as i,c as a,o as t,a6 as l}from"./chunks/framework.mq8cK8gF.js";const g=JSON.parse('{"title":"JS 堆栈执行原理","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/JS堆栈执行原理.md","filePath":"语言/JavaScript/JS堆栈执行原理.md","lastUpdated":1750738239000}'),e={name:"语言/JavaScript/JS堆栈执行原理.md"};function n(h,s,r,o,k,p){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="js-堆栈执行原理" tabindex="-1">JS 堆栈执行原理 <a class="header-anchor" href="#js-堆栈执行原理" aria-label="Permalink to “JS 堆栈执行原理”">​</a></h1><nav class="table-of-contents"><ul><li><a href="#_1-执行栈-call-stack">1. 执行栈（Call Stack）</a></li><li><a href="#_2-堆-heap">2. 堆（Heap）</a></li><li><a href="#_3-异步任务与事件循环">3. 异步任务与事件循环</a></li><li><a href="#执行顺序示例">执行顺序示例</a></li><li><a href="#关键规则总结">关键规则总结</a></li><li><a href="#常见问题">常见问题</a></li></ul></nav><p>浏览器中的堆栈执行原理主要涉及<strong>执行栈（Call Stack）</strong>、<strong>堆（Heap）</strong> 和<strong>任务队列（Event Queue）</strong>，配合<strong>事件循环（Event Loop）</strong> 实现代码执行。以下是核心原理：</p><hr><h3 id="_1-执行栈-call-stack" tabindex="-1">1. <strong>执行栈（Call Stack）</strong> <a class="header-anchor" href="#_1-执行栈-call-stack" aria-label="Permalink to “1. 执行栈（Call Stack）”">​</a></h3><ul><li><strong>作用</strong>：存储函数调用的栈结构（LIFO：后进先出）。</li><li><strong>工作流程</strong>： <ul><li>每调用一个函数，将其压入栈顶（称为“栈帧”）。</li><li>函数执行完毕后，从栈顶弹出。</li><li>栈为空时，表示代码执行结束。</li></ul></li><li><strong>示例</strong>：<div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;End&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><strong>栈顺序</strong>：<br><code>a()</code> → <code>b()</code> → <code>c()</code> → <code>console.log()</code><br> 执行后依次弹出。</li></ul><hr><h3 id="_2-堆-heap" tabindex="-1">2. <strong>堆（Heap）</strong> <a class="header-anchor" href="#_2-堆-heap" aria-label="Permalink to “2. 堆（Heap）”">​</a></h3><ul><li><strong>作用</strong>：存储复杂对象（如对象、数组等引用类型），内存分配无序。</li><li><strong>特点</strong>：变量在栈中保存对象的堆内存地址（引用）。</li></ul><hr><h3 id="_3-异步任务与事件循环" tabindex="-1">3. <strong>异步任务与事件循环</strong> <a class="header-anchor" href="#_3-异步任务与事件循环" aria-label="Permalink to “3. 异步任务与事件循环”">​</a></h3><p>JavaScript 是单线程的，异步任务（如 <code>setTimeout</code>、<code>Promise</code>）通过以下机制处理：</p><h4 id="_1-任务队列-event-queue" tabindex="-1">(1) <strong>任务队列（Event Queue）</strong> <a class="header-anchor" href="#_1-任务队列-event-queue" aria-label="Permalink to “(1) 任务队列（Event Queue）”">​</a></h4><ul><li>存储待执行的异步任务回调。</li><li>分为两种队列： <ul><li><strong>宏任务队列（Macro Task Queue）</strong>：<br><code>setTimeout</code>、<code>setInterval</code>、DOM事件、I/O操作等。</li><li><strong>微任务队列（Micro Task Queue）</strong>：<br><code>Promise.then()</code>、<code>MutationObserver</code>、<code>queueMicrotask()</code>。</li></ul></li></ul><h4 id="_2-事件循环-event-loop" tabindex="-1">(2) <strong>事件循环（Event Loop）</strong> <a class="header-anchor" href="#_2-事件循环-event-loop" aria-label="Permalink to “(2) 事件循环（Event Loop）”">​</a></h4><ol><li><strong>执行栈为空时</strong>，检查微任务队列。</li><li><strong>清空所有微任务</strong>（依次执行至队列为空）。</li><li><strong>执行一个宏任务</strong>。</li><li><strong>重复步骤1~3</strong>（循环）。</li></ol><hr><h3 id="执行顺序示例" tabindex="-1">执行顺序示例 <a class="header-anchor" href="#执行顺序示例" aria-label="Permalink to “执行顺序示例”">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Timeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;End&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><strong>输出顺序</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Start → End → Promise 1 → Promise 2 → Timeout</span></span></code></pre></div><h4 id="步骤解析" tabindex="-1">步骤解析： <a class="header-anchor" href="#步骤解析" aria-label="Permalink to “步骤解析：”">​</a></h4><ol><li>同步代码入栈：<br><code>console.log(&quot;Start&quot;)</code> → <code>console.log(&quot;End&quot;)</code>。</li><li>异步任务分发： <ul><li><code>setTimeout</code> 回调放入<strong>宏任务队列</strong>。</li><li><code>Promise.then()</code> 放入<strong>微任务队列</strong>。</li></ul></li><li>同步代码执行完毕（栈空）： <ul><li>先清空微任务队列：执行 <code>Promise.then()</code> 链（输出 <code>Promise 1</code> → <code>Promise 2</code>）。</li><li>再执行一个宏任务：<code>setTimeout</code> 回调（输出 <code>Timeout</code>）。</li></ul></li></ol><hr><h3 id="关键规则总结" tabindex="-1">关键规则总结 <a class="header-anchor" href="#关键规则总结" aria-label="Permalink to “关键规则总结”">​</a></h3><ol><li><strong>同步代码优先执行</strong>（执行栈）。</li><li><strong>微任务 &gt; 宏任务</strong>：<br> 每次栈空后，先清空所有微任务，再执行一个宏任务。</li><li><strong>渲染时机</strong>：<br> 通常在微任务之后、宏任务之前进行UI渲染（浏览器优化策略）。</li></ol><hr><h3 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to “常见问题”">​</a></h3><ul><li><strong>栈溢出（Stack Overflow）</strong>：递归未终止导致栈不断增长（如未设置递归基线）。</li><li><strong>阻塞渲染</strong>：长同步任务会阻塞UI更新（需拆分任务或使用异步）。</li></ul><p>通过理解堆栈和事件循环，可以优化代码性能并避免常见异步陷阱。</p><ol><li><a href="http://ecma-international.org/ecma-262/6.0/#sec-execution-contexts" target="_blank" rel="noreferrer">http://ecma-international.org/ecma-262/6.0/#sec-execution-contexts</a></li><li><a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf" target="_blank" rel="noreferrer">https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262, 1st edition, June 1997.pdf</a></li><li><a href="https://github.com/tc39" target="_blank" rel="noreferrer">https://github.com/tc39</a></li></ol>`,31)]))}const c=i(e,[["render",n]]);export{g as __pageData,c as default};
