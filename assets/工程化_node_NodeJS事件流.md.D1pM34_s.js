import{_ as o,c as a,o as t,a6 as l}from"./chunks/framework.mq8cK8gF.js";const d="/vite-press/assets/2020-11-19-23-19-44.yBBU1cSP.png",h=JSON.parse('{"title":"NodeJs Event Loop","description":"","frontmatter":{},"headers":[],"relativePath":"工程化/node/NodeJS事件流.md","filePath":"工程化/node/NodeJS事件流.md","lastUpdated":1749107541000}'),s={name:"工程化/node/NodeJS事件流.md"};function n(i,e,r,c,p,_){return t(),a("div",null,e[0]||(e[0]=[l('<h1 id="nodejs-event-loop" tabindex="-1">NodeJs Event Loop <a class="header-anchor" href="#nodejs-event-loop" aria-label="Permalink to “NodeJs Event Loop”">​</a></h1><h2 id="nodejs-event-loop-执行阶段" tabindex="-1">NodeJS Event Loop 执行阶段 <a class="header-anchor" href="#nodejs-event-loop-执行阶段" aria-label="Permalink to “NodeJS Event Loop 执行阶段”">​</a></h2><p><img src="'+d+'" alt="" data-zoomable="true" loading="lazy"></p><ol><li>timers: 执行 <code>setTimeout</code> 和 <code>setImmediate</code> 的回调</li><li>pending callbacks: 执行延迟到下一个循环迭代的I/O回调</li><li>idle,prepare: 仅系统内部使用</li><li>poll: 检索新的I/O事件;执行与I/O相关的回调,事件上除了其他几个阶段处理的事件,其他几乎所有的异步都在这个阶段处理</li><li>check: setImmediate 在这里执行</li><li>close callbacks: 一些关闭的回调函数, 如: socket.on(&#39;close&#39;,..)</li></ol><p>每个阶段都有一个自己的先进先出的队列,只有当这个队列的事件执行完或者达到该阶段的上限时, 才会进入下一个阶段,在每次事件循环之间,Node.js都会检查它是否在等待任何一个I/O或者定时器,如果没有的话,程序就关闭推出了,我们直观感受就是,如果一个node程序只有同步代码,你在控制台运行完后,他就自己推出了</p>',5)]))}const N=o(s,[["render",n]]);export{h as __pageData,N as default};
