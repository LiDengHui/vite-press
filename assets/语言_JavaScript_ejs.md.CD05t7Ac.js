import{_ as s,c as t,o as a,a7 as l}from"./chunks/framework.DDkSvsBP.js";const g=JSON.parse('{"title":"EJS","description":"EJS 前端模版语言学习笔记","frontmatter":{"title":"EJS","date":"2016-04-16T19:39:52.000Z","tags":"前端","categories":"技术文档","description":"EJS 前端模版语言学习笔记"},"headers":[],"relativePath":"语言/JavaScript/ejs.md","filePath":"语言/JavaScript/ejs.md","lastUpdated":1750738239000}'),e={name:"语言/JavaScript/ejs.md"};function n(h,i,p,d,r,k){return a(),t("div",null,i[0]||(i[0]=[l(`<p>之前一直没有用过EJS，一直用的jade，但是越用jade，越觉得好像被框在了圈圈里，倒不是jade的语法问题，相反我觉得jade从语法角度而言是最好的一门模版语言，对比ejs没有额外的添加代码，甚至是比html更好，但是jade由于他的简洁也造成了一个问题，如果没有html2jade 的转义很难和html相结合，特别是大多数人使用的前端模版，都是建立在html上的，所以如果不是项目开始就用jade的话就特别别扭，但是EJS却没有这类的问题，当然也付出了相应的代价在代码中看到让人眼睛发晕的<code>&lt;% %&gt;</code>标签，特别让人不舒服，这也是在刚开始学习使用模版的时候没有选择EJS的原因</p><h2 id="example" tabindex="-1">example <a class="header-anchor" href="#example" aria-label="Permalink to “example”">​</a></h2><h3 id="jade" tabindex="-1">jade <a class="header-anchor" href="#jade" aria-label="Permalink to “jade”">​</a></h3><pre><code>    !!!
    html
        head
            title #{title}
            meta(charset=&quot;UTF-8&quot;)
        body
            div.description #{description}
            ul
                - each data in datas
                    li.item(id=&#39;item_&#39;+data.index)
                        span= data.time
                        a.art(href=data.url)= data.title
</code></pre><h3 id="ejs" tabindex="-1">ejs <a class="header-anchor" href="#ejs" aria-label="Permalink to “ejs”">​</a></h3><pre><code>    &lt;!doctype html&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;%=title%&gt; - Page Test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;description&quot;&gt;&lt;%=description%&gt;&lt;/div&gt;
        &lt;ul&gt;
    &lt;% function data(data) { %&gt;
            &lt;li class=&quot;item&quot; id=&quot;item_&lt;%=data.index%&gt;&quot;&gt;&lt;span&gt;&lt;%=data.time%&gt;&lt;/span&gt;&lt;a href=&quot;&lt;%=data.url%&gt;&quot; class=&quot;art&quot;&gt;&lt;%=data.title%&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;% } %&gt;
    &lt;% datas.map(data) %&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to “语法”">​</a></h2><h3 id="标签" tabindex="-1">标签 <a class="header-anchor" href="#标签" aria-label="Permalink to “标签”">​</a></h3><ol><li><code>&lt;% ... %&gt;</code> 用来包含要执行的JS代码，凡是不需要输出文本的地方都用它</li><li><code>&lt;%= ... %&gt;</code> 用于输出文本，被包含的值解析后转换成文本</li><li><code>&lt;%- ... %&gt;</code> EJS内部语法，不进行转义，如内部模版嵌套</li><li><code>&lt;%% ... %&gt;</code> 输出&lt;%</li><li><code>&lt;%#</code> 内部注释</li><li><code>－%&gt;</code> 换行符 如果不喜欢<code>&lt;% ...%&gt;</code> 也可以换成其他的</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ejs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;语言/JavaScript/ejs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ejs.open </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;{{&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ejs.close </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;}}&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="语法-1" tabindex="-1">语法 <a class="header-anchor" href="#语法-1" aria-label="Permalink to “语法”">​</a></h3><ol><li>EJS 直接使用js内嵌，用编程的方式写html,如：</li></ol><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">% if (user) { %&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">%= user.name %&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">% } %&gt;</span></span></code></pre></div><ol start="2"><li>其主要有两种用法，一个是直接返回一个Function函数，参数为填充的数值对象，另一种是直接返回String类型的html，如：</li></ol><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> var template = ejs.compile(str, options);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        template(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        // =&gt; Rendered HTML string</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ejs.render(str, data, options);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        // =&gt; Rendered HTML string</span></span></code></pre></div><ol start="3"><li>其中options的一些参数为： <ol><li>cache：是否缓存解析后的模版，需要filename作为key；</li><li>filename：模版文件名；</li><li>scope：complile后的Function执行所在的上下文环境；</li><li>debug：标识是否是debeg状态，debug为true则会输出生成的Function内容；</li><li>compileDebug：标识是否是编译debug，为true则会生成解析过程中的跟踪信息，用于调试；</li><li>client，标识是否用于浏览器客户端运行，为true则返回解析后的可以单独运行的Function函数；</li><li>open，代码开头标记，默认为&#39;&lt;%&#39;；</li><li>close，代码结束标记，默认为&#39;%&gt;&#39;；</li><li>其他的一些用于解析模版时提供的变量。 在express中使用时，options参数将由response.render进行传入，其中包含了一些express中的设置，以及用户提供的变量值。</li></ol></li><li>此外ejs还提供了一些辅助函数，用于代替使用javascript代码，使得更加方便的操纵数据。 <ol><li>first，返回数组的第一个元素；</li><li>last，返回数组的最后一个元素；</li><li>capitalize，返回首字母大写的字符串；</li><li>downcase，返回字符串的小写；</li><li>upcase，返回字符串的大写；</li><li>sort，排序（Object.create(obj).sort()？）；</li><li>sort_by:&#39;prop&#39;，按照指定的prop属性进行升序排序；</li><li>size，返回长度，即length属性，不一定非是数组才行；</li><li>plus:n，加上n，将转化为Number进行运算；</li><li>minus:n，减去n，将转化为Number进行运算；</li><li>times:n，乘以n，将转化为Number进行运算；</li><li>divided_by:n，除以n，将转化为Number进行运算；</li><li>join:&#39;val&#39;，将数组用&#39;val&#39;最为分隔符，进行合并成一个字符串；</li><li>truncate:n，截取前n个字符，超过长度时，将返回一个副本</li><li>truncate_words:n，取得字符串中的前n个word，word以空格进行分割；</li><li>replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；</li><li>prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；</li><li>append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；</li><li>map:&#39;prop&#39;，返回对象数组中属性为prop的值组成的数组；</li><li>reverse，翻转数组或字符串；</li><li>get:&#39;prop&#39;，取得属性为&#39;prop&#39;的值；</li><li>json，转化为json格式字符串</li></ol></li><li>EJS 模版嵌套\`&lt;%- include ... %&gt;</li></ol><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">% users.forEach(function(user){ %&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">    &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">% include user/show %&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">  &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">% }) %&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结: <a class="header-anchor" href="#总结" aria-label="Permalink to “总结:”">​</a></h2><p>EJS和jade之间其实没必要太过关注，他们都是模版语言，只要你喜欢只要合适，更具具体的项目选择合适的模版就行。</p>`,19)]))}const c=s(e,[["render",n]]);export{g as __pageData,c as default};
