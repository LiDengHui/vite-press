import{aD as e,aQ as t,aW as n,ay as r,l as i,m as a,n as o,o as s,p as c,q as l,r as u,s as d,t as f,v as p,w as m,x as h}from"../app.CFsT-BMU.js";import{d as g}from"./baseUniq.ChCiZPqY.js";import{h as _}from"./basePickBy.Cljyukzj.js";import{b as v}from"./dagre.BANnqM3V.js";import{b as y}from"./clone.CI1GYA3R.js";import{b}from"./graphlib.D3VT7A7B.js";function x(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:S(e),edges:C(e)};return g(e.graph())||(t.value=y(e.graph())),t}function S(e){return _(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),i={v:t};return g(n)||(i.value=n),g(r)||(i.parent=r),i})}function C(e){return _(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return g(t.name)||(r.name=t.name),g(n)||(r.value=n),r})}var w=new Map,T=new Map,E=new Map,D=e(()=>{T.clear(),E.clear(),w.clear()},`clear`),O=e((e,t)=>{let r=T.get(t)||[];return n.trace(`In isDescendant`,t,` `,e,` = `,r.includes(e)),r.includes(e)},`isDescendant`),k=e((e,t)=>{let r=T.get(t)||[];return n.info(`Descendants of `,t,` is `,r),n.info(`Edge is `,e),e.v===t||e.w===t?!1:r?r.includes(e.v)||O(e.v,t)||O(e.w,t)||r.includes(e.w):(n.debug(`Tilt, `,t,`,not in descendants`),!1)},`edgeInCluster`),A=e((e,t,r,i)=>{n.warn(`Copying children of `,e,`root`,i,`data`,t.node(e),i);let a=t.children(e)||[];e!==i&&a.push(e),n.warn(`Copying (nodes) clusterId`,e,`nodes`,a),a.forEach(a=>{if(t.children(a).length>0)A(a,t,r,i);else{let o=t.node(a);n.info(`cp `,a,` to `,i,` with parent `,e),r.setNode(a,o),i!==t.parent(a)&&(n.warn(`Setting parent`,a,t.parent(a)),r.setParent(a,t.parent(a))),e!==i&&a!==e?(n.debug(`Setting parent`,a,e),r.setParent(a,e)):(n.info(`In copy `,e,`root`,i,`data`,t.node(e),i),n.debug(`Not Setting parent for node=`,a,`cluster!==rootId`,e!==i,`node!==clusterId`,a!==e));let s=t.edges(a);n.debug(`Copying Edges`,s),s.forEach(a=>{n.info(`Edge`,a);let o=t.edge(a.v,a.w,a.name);n.info(`Edge data`,o,i);try{k(a,i)?(n.info(`Copying as `,a.v,a.w,o,a.name),r.setEdge(a.v,a.w,o,a.name),n.info(`newGraph edges `,r.edges(),r.edge(r.edges()[0]))):n.info(`Skipping copy of edge `,a.v,`-->`,a.w,` rootId: `,i,` clusterId:`,e)}catch(e){n.error(e)}})}n.debug(`Removing node`,a),t.removeNode(a)})},`copy`),j=e((e,t)=>{let n=t.children(e),r=[...n];for(let i of n)E.set(i,e),r=[...r,...j(i,t)];return r},`extractDescendants`),M=e((e,t,n)=>{let r=e.edges().filter(e=>e.v===t||e.w===t),i=e.edges().filter(e=>e.v===n||e.w===n),a=r.map(e=>({v:e.v===t?n:e.v,w:e.w===t?t:e.w})),o=i.map(e=>({v:e.v,w:e.w})),s=a.filter(e=>o.some(t=>e.v===t.v&&e.w===t.w));return s},`findCommonEdges`),N=e((e,t,r)=>{let i=t.children(e);if(n.trace(`Searching children of id `,e,i),i.length<1)return e;let a;for(let e of i){let n=N(e,t,r),i=M(t,r,n);if(n)if(i.length>0)a=n;else return n}return a},`findNonClusterChild`),P=e(e=>!w.has(e)||!w.get(e).externalConnections?e:w.has(e)?w.get(e).id:e,`getAnchorId`),F=e((e,t)=>{if(!e||t>10){n.debug(`Opting out, no graph `);return}else n.debug(`Opting in, graph `);e.nodes().forEach(function(t){let r=e.children(t);r.length>0&&(n.warn(`Cluster identified`,t,` Replacement id in edges: `,N(t,e,t)),T.set(t,j(t,e)),w.set(t,{id:N(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){let r=e.children(t),i=e.edges();r.length>0?(n.debug(`Cluster identified`,t,T),i.forEach(e=>{let r=O(e.v,t),i=O(e.w,t);r^i&&(n.warn(`Edge: `,e,` leaves cluster `,t),n.warn(`Descendants of XXX `,t,`: `,T.get(t)),w.get(t).externalConnections=!0)})):n.debug(`Not a cluster `,t,T)});for(let t of w.keys()){let n=w.get(t).id,r=e.parent(n);r!==t&&w.has(r)&&!w.get(r).externalConnections&&(w.get(t).id=r)}e.edges().forEach(function(t){let r=e.edge(t);n.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(t)),n.warn(`Edge `+t.v+` -> `+t.w+`: `+JSON.stringify(e.edge(t)));let i=t.v,a=t.w;if(n.warn(`Fix XXX`,w,`ids:`,t.v,t.w,`Translating: `,w.get(t.v),` --- `,w.get(t.w)),w.get(t.v)||w.get(t.w)){if(n.warn(`Fixing and trying - removing XXX`,t.v,t.w,t.name),i=P(t.v),a=P(t.w),e.removeEdge(t.v,t.w,t.name),i!==t.v){let n=e.parent(i);w.get(n).externalConnections=!0,r.fromCluster=t.v}if(a!==t.w){let n=e.parent(a);w.get(n).externalConnections=!0,r.toCluster=t.w}n.warn(`Fix Replacing with XXX`,i,a,t.name),e.setEdge(i,a,r,t.name)}}),n.warn(`Adjusted Graph`,x(e)),I(e,0),n.trace(w)},`adjustClustersAndEdges`),I=e((e,t)=>{if(n.warn(`extractor - `,t,x(e),e.children(`D`)),t>10){n.error(`Bailing out`);return}let r=e.nodes(),i=!1;for(let t of r){let n=e.children(t);i||=n.length>0}if(!i){n.debug(`Done, no node has children`,e.nodes());return}n.debug(`Nodes = `,r,t);for(let i of r)if(n.debug(`Extracting node`,i,w,w.has(i)&&!w.get(i).externalConnections,!e.parent(i),e.node(i),e.children(`D`),` Depth `,t),!w.has(i))n.debug(`Not a cluster`,i,t);else if(!w.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){n.warn(`Cluster without external connections, without a parent and with children`,i,t);let r=e.graph(),a=r.rankdir===`TB`?`LR`:`TB`;w.get(i)?.clusterData?.dir&&(a=w.get(i).clusterData.dir,n.warn(`Fixing dir`,w.get(i).clusterData.dir,a));let o=new b({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});n.warn(`Old graph before copy`,x(e)),A(i,e,o,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:w.get(i).clusterData,label:w.get(i).label,graph:o}),n.warn(`New graph after copy node: (`,i,`)`,x(o)),n.debug(`Old graph after copy`,x(e))}else n.warn(`Cluster ** `,i,` **not meeting the criteria !externalConnections:`,!w.get(i).externalConnections,` no parent: `,!e.parent(i),` children `,e.children(i)&&e.children(i).length>0,e.children(`D`),t),n.debug(w);r=e.nodes(),n.warn(`New list of nodes`,r);for(let i of r){let r=e.node(i);n.warn(` Now next level`,i,r),r?.clusterNode&&I(r.graph,t+1)}},`extractor`),L=e((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(t=>{let r=e.children(t),i=L(e,r);n=[...n,...i]}),n},`sorter`),R=e(e=>L(e,e.children()),`sortNodesByHierarchy`),z=e(async(t,i,s,l,u,g)=>{n.warn(`Graph in recursive render:XAX`,x(i),u);let _=i.graph().rankdir;n.trace(`Dir in recursive render - dir:`,_);let y=t.insert(`g`).attr(`class`,`root`);i.nodes()?n.info(`Recursive render XXX`,i.nodes()):n.info(`No nodes found for`,i),i.edges().length>0&&n.info(`Recursive edges`,i.edge(i.edges()[0]));let b=y.insert(`g`).attr(`class`,`clusters`),S=y.insert(`g`).attr(`class`,`edgePaths`),C=y.insert(`g`).attr(`class`,`edgeLabels`),T=y.insert(`g`).attr(`class`,`nodes`);await Promise.all(i.nodes().map(async function(e){let t=i.node(e);if(u!==void 0){let t=JSON.parse(JSON.stringify(u.clusterData));n.trace(`Setting data for parent cluster XXX
 Node.id = `,e,`
 data=`,t.height,`
Parent cluster`,u.height),i.setNode(u.id,t),i.parent(e)||(n.trace(`Setting parent`,e,u.id),i.setParent(e,u.id,t))}if(n.info(`(Insert) Node XXX`+e+`: `+JSON.stringify(i.node(e))),t?.clusterNode){n.info(`Cluster identified XBX`,e,t.width,i.node(e));let{ranksep:r,nodesep:a}=i.graph();t.graph.setGraph({...t.graph.graph(),ranksep:r+25,nodesep:a});let o=await z(T,t.graph,s,l,i.node(e),g),c=o.elem;h(t,c),t.diff=o.diff||0,n.info(`New compound node after recursive render XAX`,e,`width`,t.width,`height`,t.height),m(c,t)}else i.children(e).length>0?(n.trace(`Cluster - the non recursive path XBX`,e,t.id,t,t.width,`Graph:`,i),n.trace(N(t.id,i)),w.set(t.id,{id:N(t.id,i),node:t})):(n.trace(`Node - the non recursive path XAX`,e,T,i.node(e),_),await f(T,i.node(e),{config:g,dir:_}))}));let E=e(async()=>{let e=i.edges().map(async function(e){let t=i.edge(e.v,e.w,e.name);n.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(e)),n.info(`Edge `+e.v+` -> `+e.w+`: `,e,` `,JSON.stringify(i.edge(e))),n.info(`Fix`,w,`ids:`,e.v,e.w,`Translating: `,w.get(e.v),w.get(e.w)),await o(C,t)});await Promise.all(e)},`processEdges`);await E(),n.info(`Graph before layout:`,JSON.stringify(x(i))),n.info(`############################################# XXX`),n.info(`###                Layout                 ### XXX`),n.info(`############################################# XXX`),v(i),n.info(`Graph after layout:`,JSON.stringify(x(i)));let D=0,{subGraphTitleTotalMargin:O}=r(g);return await Promise.all(R(i).map(async function(e){let t=i.node(e);if(n.info(`Position XBX => `+e+`: (`+t.x,`,`+t.y,`) width: `,t.width,` height: `,t.height),t?.clusterNode)t.y+=O,n.info(`A tainted cluster node XBX1`,e,t.id,t.width,t.height,t.x,t.y,i.parent(e)),w.get(t.id).node=t,p(t);else if(i.children(e).length>0){n.info(`A pure cluster node XBX1`,e,t.id,t.x,t.y,t.width,t.height,i.parent(e)),t.height+=O,i.node(t.parentId);let r=t?.padding/2||0,a=t?.labelBBox?.height||0,o=a-r||0;n.debug(`OffsetY`,o,`labelHeight`,a,`halfPadding`,r),await d(b,t),w.get(t.id).node=t}else{let e=i.node(t.parentId);t.y+=O/2,n.info(`A regular node XBX1 - using the padding`,t.id,`parent`,t.parentId,t.width,t.height,t.x,t.y,`offsetY`,t.offsetY,`parent`,e,e?.offsetY,t),p(t)}})),i.edges().forEach(function(e){let t=i.edge(e);n.info(`Edge `+e.v+` -> `+e.w+`: `+JSON.stringify(t),t),t.points.forEach(e=>e.y+=O/2);let r=i.node(e.v);var o=i.node(e.w);let u=a(S,t,w,s,r,o,l);c(t,u)}),i.nodes().forEach(function(e){let t=i.node(e);n.info(e,t.type,t.diff),t.isGroup&&(D=t.diff)}),n.warn(`Returning from recursive render XAX`,y,D),{elem:y,diff:D}},`recursiveRender`),B=e(async(e,r)=>{let a=new b({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=r.select(`g`);s(o,e.markers,e.type,e.diagramId),u(),i(),l(),D(),e.nodes.forEach(e=>{a.setNode(e.id,{...e}),e.parentId&&a.setParent(e.id,e.parentId)}),n.debug(`Edges:`,e.edges),e.edges.forEach(e=>{if(e.start===e.end){let t=e.start,n=t+`---`+t+`---1`,r=t+`---`+t+`---2`,i=a.node(t);a.setNode(n,{domId:n,id:n,parentId:i.parentId,labelStyle:``,label:``,padding:0,shape:`labelRect`,style:``,width:10,height:10}),a.setParent(n,i.parentId),a.setNode(r,{domId:r,id:r,parentId:i.parentId,labelStyle:``,padding:0,shape:`labelRect`,label:``,style:``,width:10,height:10}),a.setParent(r,i.parentId);let o=structuredClone(e),s=structuredClone(e),c=structuredClone(e);o.label=``,o.arrowTypeEnd=`none`,o.id=t+`-cyclic-special-1`,s.arrowTypeStart=`none`,s.arrowTypeEnd=`none`,s.id=t+`-cyclic-special-mid`,c.label=``,i.isGroup&&(o.fromCluster=t,c.toCluster=t),c.id=t+`-cyclic-special-2`,c.arrowTypeStart=`none`,a.setEdge(t,n,o,t+`-cyclic-special-0`),a.setEdge(n,r,s,t+`-cyclic-special-1`),a.setEdge(r,t,c,t+`-cyc<lic-special-2`)}else a.setEdge(e.start,e.end,{...e},e.id)}),n.warn(`Graph at first:`,JSON.stringify(x(a))),F(a),n.warn(`Graph after XAX:`,JSON.stringify(x(a)));let c=t();await z(o,a,e.type,e.diagramId,void 0,c)},`render`);export{B as render};