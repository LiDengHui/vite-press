import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.CL7LGUog.js";const i=JSON.parse(`{"title":"String与StringBuilder的区别","description":"","frontmatter":{},"headers":[],"relativePath":"语言/后端/String与StringBuilder.md","filePath":"语言/后端/String与StringBuilder.md","lastUpdated":1750738239000}`),a={name:`语言/后端/String与StringBuilder.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="string与stringbuilder的区别" tabindex="-1">String与StringBuilder的区别 <a class="header-anchor" href="#string与stringbuilder的区别" aria-label="Permalink to “String与StringBuilder的区别”">​</a></h1><p>在 Java 中，<code>String</code> 和 <code>StringBuilder</code> (以及它的线程安全版本 <code>StringBuffer</code>) 是处理字符串的核心类，它们的关键区别在于 <strong>可变性</strong> 及其带来的性能影响。以下是主要区别：</p><ol><li><p><strong>不可变性 vs 可变性</strong></p><ul><li><strong><code>String</code> (不可变)：</strong> <code>String</code> 对象一旦创建，其内容<strong>就不能被修改</strong>。任何看似修改 <code>String</code> 的操作（如 <code>concat()</code>, <code>+</code>, <code>replace()</code>, <code>substring()</code>, <code>toUpperCase()</code> 等），实际上都会创建一个<strong>全新的</strong> <code>String</code> 对象在内存中。原始字符串保持不变。</li><li><strong><code>StringBuilder</code> (可变)：</strong> <code>StringBuilder</code> 对象代表一个<strong>可变的字符序列</strong>。你可以通过其方法（如 <code>append()</code>, <code>insert()</code>, <code>delete()</code>, <code>replace()</code>, <code>reverse()</code> 等）<strong>直接修改</strong>其内部字符数组的内容，<strong>而不会创建新的对象</strong>（除非内部数组需要扩容）。</li></ul></li><li><p><strong>性能 (尤其是在循环或频繁修改时)</strong></p><ul><li><strong><code>String</code>：</strong> 由于不可变性，在循环或需要大量拼接/修改字符串的场景下（例如在一个循环中反复使用 <code>+=</code> 或 <code>concat()</code>），会<strong>产生大量临时的、中间态的 <code>String</code> 对象</strong>。创建和销毁这些对象会带来显著的<strong>内存分配和垃圾回收开销</strong>，导致<strong>性能低下</strong>。</li><li><strong><code>StringBuilder</code>：</strong> 由于直接在现有缓冲区上修改，避免了创建大量临时对象。它在进行大量字符串连接或修改操作时<strong>性能显著优于 <code>String</code></strong>。这是它存在的主要原因。</li></ul></li><li><p><strong>内存使用</strong></p><ul><li><strong><code>String</code>：</strong> 频繁修改会导致内存中存在许多不再使用的中间字符串对象，等待垃圾回收。这会<strong>占用更多内存</strong>，并可能增加 GC 停顿时间。</li><li><strong><code>StringBuilder</code>：</strong> 通常更<strong>节省内存</strong>，尤其是在大量修改操作中，因为它主要操作一个可扩展的缓冲区。虽然内部数组在需要时会扩容（创建新数组并复制数据），但这比创建大量完整的新字符串对象开销小得多。</li></ul></li><li><p><strong>线程安全性</strong></p><ul><li><strong><code>String</code>：</strong> 由于其不可变性，<code>String</code> 对象本质上是<strong>线程安全</strong>的。多个线程可以安全地读取同一个 <code>String</code> 对象。</li><li><strong><code>StringBuilder</code>：</strong> <strong>不是线程安全</strong>的。它的方法没有同步机制。如果多个线程需要同时修改同一个 <code>StringBuilder</code> 实例，可能会导致数据不一致。如果需要线程安全，应使用 <code>StringBuffer</code>（其方法使用 <code>synchronized</code> 关键字修饰）。</li></ul></li><li><p><strong>API 和初始化</strong></p><ul><li><strong><code>String</code>：</strong> 通常通过双引号 <code>&quot;Hello&quot;</code> 字面量创建（存储在字符串常量池），或通过 <code>new String(...)</code> 创建（在堆上）。提供丰富的字符串操作功能，但都返回新字符串。</li><li><strong><code>StringBuilder</code>：</strong> 必须通过 <code>new StringBuilder()</code> 或 <code>new StringBuilder(int capacity)</code> 或 <code>new StringBuilder(String str)</code> 创建。提供专注于修改缓冲区内容的方法（<code>append</code>, <code>insert</code>, <code>delete</code>, <code>replace</code>, <code>setLength</code>, <code>reverse</code> 等）。</li></ul></li><li><p><strong><code>equals()</code> 和 <code>hashCode()</code> 行为</strong></p><ul><li><strong><code>String</code>：</strong> 重写了 <code>equals()</code> 和 <code>hashCode()</code> 方法，基于字符串的<strong>内容</strong>进行比较。</li><li><strong><code>StringBuilder</code>：</strong> <strong>没有重写</strong> <code>Object</code> 的 <code>equals()</code> 和 <code>hashCode()</code> 方法。比较两个 <code>StringBuilder</code> 对象是基于<strong>对象引用</strong>（内存地址），而不是内容。要比较内容，需要先调用 <code>toString()</code> 转换为 <code>String</code> 再比较。</li></ul></li></ol><p><strong>总结表格</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;"><code>String</code></th><th style="text-align:left;"><code>StringBuilder</code></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>可变性</strong></td><td style="text-align:left;"><strong>不可变</strong></td><td style="text-align:left;"><strong>可变</strong></td></tr><tr><td style="text-align:left;"><strong>修改操作</strong></td><td style="text-align:left;">创建新对象</td><td style="text-align:left;">修改现有对象</td></tr><tr><td style="text-align:left;"><strong>性能 (修改)</strong></td><td style="text-align:left;"><strong>差</strong> (大量对象创建/GC)</td><td style="text-align:left;"><strong>优</strong> (原地修改)</td></tr><tr><td style="text-align:left;"><strong>内存开销</strong></td><td style="text-align:left;"><strong>高</strong> (大量中间对象)</td><td style="text-align:left;"><strong>低</strong> (一个缓冲区)</td></tr><tr><td style="text-align:left;"><strong>线程安全</strong></td><td style="text-align:left;"><strong>是</strong> (因不可变)</td><td style="text-align:left;"><strong>否</strong> (用 <code>StringBuffer</code> 替代)</td></tr><tr><td style="text-align:left;"><strong>初始化</strong></td><td style="text-align:left;">字面量 或 <code>new String(...)</code></td><td style="text-align:left;"><code>new StringBuilder(...)</code></td></tr><tr><td style="text-align:left;"><strong><code>equals/hash</code></strong></td><td style="text-align:left;">基于<strong>内容</strong></td><td style="text-align:left;">基于<strong>对象引用</strong></td></tr><tr><td style="text-align:left;"><strong>主要用途</strong></td><td style="text-align:left;">表示固定不变的文本</td><td style="text-align:left;">高效构建或修改字符串 (拼接、替换等)</td></tr></tbody></table><p><strong>何时使用哪个？</strong></p><ol><li><p><strong>使用 <code>String</code>：</strong></p><ul><li>当字符串的值在创建后<strong>不会改变</strong>时（例如，常量、配置信息、键值）。</li><li>需要依赖内容比较 (<code>equals</code>) 或哈希 (<code>hashCode</code>) 时。</li><li>需要线程安全地共享字符串时（读取是安全的）。</li><li>简单的、少量的字符串连接（编译器有时会优化 <code>+</code> 为 <code>StringBuilder</code>，但<strong>不要在循环中依赖此优化！</strong>）。</li></ul></li><li><p><strong>使用 <code>StringBuilder</code> (或 <code>StringBuffer</code>)：</strong></p><ul><li>当需要在<strong>循环</strong>中<strong>频繁连接</strong>字符串时（<strong>绝对首选</strong>）。</li><li>当需要<strong>多次修改</strong>一个字符串的内容（插入、删除、替换等）时。</li><li>当<strong>性能</strong>和<strong>内存效率</strong>是关键考虑因素，且修改操作很多时。</li><li><strong><code>StringBuffer</code> vs <code>StringBuilder</code>:</strong> 需要线程安全时用 <code>StringBuffer</code>；单线程环境下追求最高性能用 <code>StringBuilder</code>（更常用）。</li></ul></li></ol><p><strong>黄金法则：</strong></p><ul><li><strong>永远不要</strong>在循环中使用 <code>String</code> 的 <code>+</code> 或 <code>concat</code> 进行大量拼接！<strong>始终使用 <code>StringBuilder</code> (或 <code>StringBuffer</code>)</strong>。</li><li>对于简单的、单次的字符串连接，<code>String</code> 的 <code>+</code> 是可读且可接受的（编译器通常会优化）。</li><li>优先考虑代码可读性和正确性，在性能确实成为瓶颈时才进行优化。但在循环拼接这个特定场景下，从一开始就用 <code>StringBuilder</code> 就是最佳实践。</li></ul>`,9)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};