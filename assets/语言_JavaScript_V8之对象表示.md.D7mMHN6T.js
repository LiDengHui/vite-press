import{F as e,b as t,m as n,p as r}from"./chunks/plugin-vue_export-helper.CL7LGUog.js";const i=JSON.parse(`{"title":"V8之对象表示","description":"","frontmatter":{},"headers":[],"relativePath":"语言/JavaScript/V8之对象表示.md","filePath":"语言/JavaScript/V8之对象表示.md","lastUpdated":1751812369000}`),a={name:`语言/JavaScript/V8之对象表示.md`};function o(t,i,a,o,s,c){return e(),n(`div`,null,i[0]||=[r(`<h1 id="v8之对象表示" tabindex="-1">V8之对象表示 <a class="header-anchor" href="#v8之对象表示" aria-label="Permalink to “V8之对象表示”">​</a></h1><p>在 V8 引擎中，JavaScript 对象在内存中的表示是一个高度优化的复杂结构，核心目标是兼顾<strong>动态灵活性</strong>和<strong>访问性能</strong>。以下是关键实现机制：</p><hr><h2 id="_1-隐藏类-hidden-class-map" tabindex="-1">1. <strong>隐藏类（Hidden Class / Map）</strong> <a class="header-anchor" href="#_1-隐藏类-hidden-class-map" aria-label="Permalink to “1. 隐藏类（Hidden Class / Map）”">​</a></h2><ul><li><strong>核心作用</strong>：描述对象的结构（&quot;形状&quot;）。</li><li><strong>创建机制</strong>： <ul><li>初始空对象对应一个基础隐藏类。</li><li>每新增/删除属性时，V8 动态生成新隐藏类（通过 <code>transition</code> 指针链接）。</li><li>相同结构的对象<strong>共享同一个隐藏类</strong>。</li></ul></li><li><strong>存储内容</strong>： <ul><li>属性名称、类型（Smi/Double/HeapObject）、偏移量（offset）。</li><li>指向父隐藏类的指针（用于原型链）。</li></ul></li><li><strong>优化意义</strong>：避免字典查询，直接通过偏移量访问属性。</li></ul><hr><h2 id="_2-属性存储策略" tabindex="-1">2. <strong>属性存储策略</strong> <a class="header-anchor" href="#_2-属性存储策略" aria-label="Permalink to “2. 属性存储策略”">​</a></h2><p>V8 根据属性类型采用不同存储方式：</p><ul><li><strong>命名属性（Named Properties）</strong>： <ul><li><strong>快速模式（Fast Properties）</strong>： <ul><li>内联存储：属性值直接存储在对象主体（<code>JSObject</code>）中（通过隐藏类偏移量访问）。</li><li>溢出存储：若属性过多，额外分配 <code>PropertyArray</code> 存储（偏移量仍由隐藏类管理）。</li></ul></li><li><strong>慢速模式（Slow Properties）</strong>： <ul><li>使用 <code>PropertyDictionary</code>（哈希表），牺牲速度换取内存（如频繁增删属性时）。</li></ul></li></ul></li><li><strong>索引属性（Elements）</strong>： <ul><li>数字键属性（如数组索引）存储在单独的 <code>elements</code> 数组。</li><li>根据元素类型（如全整数、双精度浮点数、稀疏性）选择优化模式（如 <code>PACKED_SMI_ELEMENTS</code>）。</li></ul></li></ul><hr><h2 id="_3-对象内存布局示例" tabindex="-1">3. <strong>对象内存布局示例</strong> <a class="header-anchor" href="#_3-对象内存布局示例" aria-label="Permalink to “3. 对象内存布局示例”">​</a></h2><p>一个普通 <code>JSObject</code> 在堆内存中的结构：</p><div class="language-plaintext"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>+-------------------+</span></span>
<span class="line"><span>| Map (隐藏类指针)   | → 指向描述对象结构的隐藏类</span></span>
<span class="line"><span>+-------------------+</span></span>
<span class="line"><span>| Properties        | → 指向命名属性存储（内联或 PropertyArray）</span></span>
<span class="line"><span>+-------------------+</span></span>
<span class="line"><span>| Elements          | → 指向索引属性存储（如数组元素）</span></span>
<span class="line"><span>+-------------------+</span></span>
<span class="line"><span>| In-object fields  | → 内联属性值（固定大小，快速访问）</span></span>
<span class="line"><span>| ...               | </span></span>
<span class="line"><span>+-------------------+</span></span></code></pre></div><ul><li><strong>内联属性（In-object）</strong>：直接嵌入对象内存，访问最快。</li><li><strong>溢出属性（Out-of-object）</strong>：存储在 <code>Properties</code> 指向的数组中。</li></ul><hr><h2 id="_4-优化技术" tabindex="-1">4. <strong>优化技术</strong> <a class="header-anchor" href="#_4-优化技术" aria-label="Permalink to “4. 优化技术”">​</a></h2><ul><li><strong>内联缓存（Inline Cache, IC）</strong>： <ul><li>缓存属性访问路径（隐藏类 + 偏移量），后续相同类型对象直接命中缓存。</li></ul></li><li><strong>指针压缩（Pointer Compression）</strong>： <ul><li>V8 使用 32 位偏移量表示堆内地址（节省内存）。</li></ul></li><li><strong>未初始化字段跟踪</strong>： <ul><li>跳过未定义属性的存储，减少内存占用。</li></ul></li></ul><hr><h2 id="_5-特殊对象处理" tabindex="-1">5. <strong>特殊对象处理</strong> <a class="header-anchor" href="#_5-特殊对象处理" aria-label="Permalink to “5. 特殊对象处理”">​</a></h2><ul><li><strong>数组</strong>： <ul><li>使用 <code>elements</code> 指针指向连续内存，根据元素类型切换优化模式。</li><li>稀疏数组退化为字典模式（<code>DictionaryElements</code>）。</li></ul></li><li><strong>函数</strong>： <ul><li>附加 <code>JSFunction</code> 结构存储代码、闭包等元数据。</li></ul></li><li><strong>原型链</strong>： <ul><li>隐藏类中存储原型指针，属性访问沿原型链向上查找。</li></ul></li></ul><hr><h2 id="_6-模式转换场景" tabindex="-1">6. <strong>模式转换场景</strong> <a class="header-anchor" href="#_6-模式转换场景" aria-label="Permalink to “6. 模式转换场景”">​</a></h2><table tabindex="0"><thead><tr><th>操作</th><th>转换结果</th></tr></thead><tbody><tr><td>动态添加大量属性</td><td>快属性 → 慢属性（字典模式）</td></tr><tr><td>删除非最后添加的属性</td><td>触发隐藏类分支，可能降级为慢属性</td></tr><tr><td>数组出现空洞或混合类型</td><td>退化到字典模式或非优化模式</td></tr></tbody></table><hr><h2 id="性能启示" tabindex="-1">性能启示 <a class="header-anchor" href="#性能启示" aria-label="Permalink to “性能启示”">​</a></h2><ol><li><strong>尽量保持对象结构稳定</strong>（避免隐藏类频繁变更）。</li><li><strong>按相同顺序初始化属性</strong>（确保隐藏类共享）。</li><li><strong>避免删除属性</strong>（用 <code>null</code> 替代删除操作）。</li><li><strong>优先使用数字连续的数组</strong>（保持 <code>PACKED</code> 模式）。</li></ol><p>通过隐藏类与精细的存储策略，V8 在动态语言特性下实现了接近静态语言的访问效率，是 JavaScript 高性能的关键基石。</p><h2 id="对象的顺序问题" tabindex="-1">对象的顺序问题 <a class="header-anchor" href="#对象的顺序问题" aria-label="Permalink to “对象的顺序问题”">​</a></h2><p>在 JavaScript 中，<code>for...in</code> 循环遍历对象的属性时，会遵循特定的顺序规则。具体来说，属性的遍历顺序遵循以下规则：</p><ol><li><strong>数字属性（numeric keys）</strong>：按照数字的升序排列。</li><li><strong>字符串属性（string keys）</strong>：按照属性被添加到对象的顺序排列。</li><li><strong>Symbol 属性（symbol keys）</strong>：按照属性被添加到对象的顺序排列。</li></ol><p>在你的代码中，<code>obj</code> 有以下属性：</p><ul><li><code>&quot;2&quot;</code>（数字属性，虽然写成 <code>2</code>，但会被隐式转换为字符串）</li><li><code>&quot;1&quot;</code>（数字属性）</li><li><code>&quot;p2&quot;</code>（字符串属性）</li><li><code>&quot;p1&quot;</code>（字符串属性）</li></ul><h2 id="遍历顺序的详细解释" tabindex="-1">遍历顺序的详细解释： <a class="header-anchor" href="#遍历顺序的详细解释" aria-label="Permalink to “遍历顺序的详细解释：”">​</a></h2><ol><li><strong>数字属性优先</strong>：<code>&quot;1&quot;</code> 和 <code>&quot;2&quot;</code> 是数字属性（即使写成 <code>1</code> 和 <code>2</code>，它们也会被隐式转换为字符串），所以会先被遍历，并按数字升序排列：</li></ol><ul><li><code>&quot;1&quot;</code></li><li><code>&quot;2&quot;</code></li></ul><ol start="2"><li><strong>字符串属性按添加顺序</strong>：剩下的 <code>&quot;p2&quot;</code> 和 <code>&quot;p1&quot;</code> 是字符串属性，按照它们被添加到对象的顺序排列：</li></ol><ul><li><code>&quot;p2&quot;</code>（先添加）</li><li><code>&quot;p1&quot;</code>（后添加）</li></ul><p>因此，最终的遍历顺序是：<code>&quot;1&quot;</code>, <code>&quot;2&quot;</code>, <code>&quot;p2&quot;</code>, <code>&quot;p1&quot;</code>。</p><h2 id="验证代码" tabindex="-1">验证代码： <a class="header-anchor" href="#验证代码" aria-label="Permalink to “验证代码：”">​</a></h2><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p2: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;aaa&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;aaa&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;aaa&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p1: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;aaa&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>输出：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>1</span></span>
<span class="line"><span>2</span></span>
<span class="line"><span>p2</span></span>
<span class="line"><span>p1</span></span></code></pre></div><h2 id="补充说明" tabindex="-1">补充说明： <a class="header-anchor" href="#补充说明" aria-label="Permalink to “补充说明：”">​</a></h2><ul><li>在 ES6 及之后的标准中，<code>for...in</code> 的顺序是规范化的（遵循上述规则），但在旧版 JavaScript 中可能不完全一致。</li><li>如果你需要完全控制属性的顺序，可以使用 <code>Map</code> 或单独维护一个属性名的数组。</li></ul>`,44)])}var s=t(a,[[`render`,o]]);export{i as __pageData,s as default};