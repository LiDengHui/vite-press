import{_ as i,c as l,o as e,a3 as s}from"./chunks/framework.DWgr2bMN.js";const t="data:image/png;base64,",g=JSON.parse('{"title":"Canvas","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/canvas.md","filePath":"浏览器/canvas.md","lastUpdated":1749107541000}'),n={name:"浏览器/canvas.md"};function h(r,a,o,d,c,p){return e(),l("div",null,a[0]||(a[0]=[s(`<h1 id="canvas" tabindex="-1">Canvas <a class="header-anchor" href="#canvas" aria-label="Permalink to “Canvas”">​</a></h1><h2 id="渲染上下文" tabindex="-1">渲染上下文 <a class="header-anchor" href="#渲染上下文" aria-label="Permalink to “渲染上下文”">​</a></h2><p><code>&lt;canvas&gt; </code>会创建一个固定大小的画布，会公开一个或多个渲染上下文(画笔)</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;tutorial&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (canvas.getContext){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // drawing code here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // canvas-unsupported code here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="绘制形状" tabindex="-1">绘制形状 <a class="header-anchor" href="#绘制形状" aria-label="Permalink to “绘制形状”">​</a></h2><p><img src="`+t+`" alt=""></p><h3 id="绘制矩形" tabindex="-1">绘制矩形 <a class="header-anchor" href="#绘制矩形" aria-label="Permalink to “绘制矩形”">​</a></h3><ol><li>fillRect(x, y, width, height): 绘制填充矩形</li><li>strokeRect(x,y, width,height): 绘制矩形边框</li><li>clearRect(x,y,width,height): 清除指定的矩形区域,然后这块区域就会变成完全透明</li></ol><h3 id="绘制路径-path" tabindex="-1">绘制路径(path) <a class="header-anchor" href="#绘制路径-path" aria-label="Permalink to “绘制路径(path)”">​</a></h3><p>步骤:</p><ol><li>创建路径起始点</li><li>调用绘制方法去绘制出路径</li><li>把路径封闭</li></ol><p>方法:</p><ol><li>beginPath(): 新建一条路径,路径一旦创建成功,图形绘制命令就会被指向路径上生成路径</li><li>moveTo(x, y): 把画笔移动到指定的坐标(x, y).相当于设置路径的起始点坐标</li><li>closePath(): 闭合路径之后,图形绘制命令又重新指向到上下文, 也可以选择不闭合</li><li>stroke(): 通过线条来绘制图形轮廓</li><li>fill(): 通过填充路径的内容区域生成实心图形</li></ol><h3 id="绘制圆弧" tabindex="-1">绘制圆弧 <a class="header-anchor" href="#绘制圆弧" aria-label="Permalink to “绘制圆弧”">​</a></h3><p>方法:</p><ol><li>arc(x, y, r, startAngle. engAngle, anticlockwise): 以(x, y)为圆心,以r为半径,从startAngle弧度开始到endAngle弧度结束,anticlosewise 是 boolean, true表示逆时针,false表示顺时针</li><li>arcTo(x1,y1,x2,y2,radius): 根据给定的控制点和半径画一段圆弧,最后再以直线连接两个控制点</li></ol><h3 id="绘制贝塞尔曲线" tabindex="-1">绘制贝塞尔曲线 <a class="header-anchor" href="#绘制贝塞尔曲线" aria-label="Permalink to “绘制贝塞尔曲线”">​</a></h3><p>方法</p><ol><li>quadraticCurveTo(cp1x, cp1y, x, y): 二次贝塞尔曲线: cp1x、cp1y控制点, x,y为结束点</li><li>quadraticCurveTo(cp1x, cp1y, cp2x, cp2y,x,y): 三次贝塞尔曲线: cp1x、cp1y控制点1, cp2x、cp2y控制点2, x,y为结束点</li></ol><h2 id="添加样式和颜色" tabindex="-1">添加样式和颜色 <a class="header-anchor" href="#添加样式和颜色" aria-label="Permalink to “添加样式和颜色”">​</a></h2><h3 id="颜色" tabindex="-1">颜色 <a class="header-anchor" href="#颜色" aria-label="Permalink to “颜色”">​</a></h3><ol><li>fillStyle = color: 设置图形的填充颜色</li><li>strokeStyle = color: 设置图形的轮廓颜色</li></ol><h3 id="透明度" tabindex="-1">透明度 <a class="header-anchor" href="#透明度" aria-label="Permalink to “透明度”">​</a></h3><ol><li>globalAlpha = transparencyValue: 这个属性影响多canvas 里所有的图形的透明度, 有效的值的范围是 0.0 (完全透明) 到 1.0 (完全不透明), 默认是1.0</li><li>lineWidth = 10; 线款只能是正值, 默认是1.0. 起始点和终点的连线为中心,上下各占线宽的一半</li><li>lineCap = “butt”|“round”|“square”; <blockquote><ol><li>&quot;butt&quot;: 线段末端以方形结束,</li><li>“round”: 线段末端以圆形结束,</li><li>“square”: 线段末端以方形结束, 但是增加了一个宽度和线段相同, 高度是线段厚度一半的矩形区域</li></ol></blockquote></li><li>lineJoin = “round”| “bevel”|“miter”; <blockquote><ol><li>round: 通过填充一个额外的,圆心在相连部分末端的扇形, 绘制拐角的形状.圆角的半径是线段的宽度</li><li>bevel: 在相连部分的末端填充一个额外的以三角形为底的区域,每个部分都有各自独立的矩形拐角</li><li>miter(默认): 通过延伸相连部分的外边缘,使其相交于一点,形成一个额外的菱形区域</li></ol></blockquote></li><li>虚线: <blockquote><p>setLineDash([20,5]) : 实线长度, 间隙长度 lineDashOffset = -0 : 设置起始偏移量</p></blockquote></li></ol><h2 id="绘制文本" tabindex="-1">绘制文本 <a class="header-anchor" href="#绘制文本" aria-label="Permalink to “绘制文本”">​</a></h2><ol><li>fillText(text, x, y, [,maxWidth]) 在指定的(x,y)位置填充指定的文本, 绘制的最大宽度是可选的</li><li>strokeText(text, x,y, [,maxWidth]) 在指定的(x,y)位置绘制文本边框, 绘制的最大宽度是可选的</li></ol><h3 id="文本样式" tabindex="-1">文本样式 <a class="header-anchor" href="#文本样式" aria-label="Permalink to “文本样式”">​</a></h3><ol><li>font = “10px sans-serif&quot; 与 CSS Font 属性相同</li><li>textAlign = “start,end,left,right,center” 默认 start</li><li>textBaseLine =“top,hanging,middle,alphabetic,ideographic,bottom” 默认 “alphabetic”</li><li>direction = value 文本方向, 可能的值包括 ltr,rtl,inherit 默认的值是 inherit</li></ol><h2 id="绘制图片" tabindex="-1">绘制图片 <a class="header-anchor" href="#绘制图片" aria-label="Permalink to “绘制图片”">​</a></h2><p>drawImage(image, x, y)</p><h3 id="缩放" tabindex="-1">缩放 <a class="header-anchor" href="#缩放" aria-label="Permalink to “缩放”">​</a></h3><blockquote><p>drawImage(image, x, y, width, height); width\\height 表示image画入canvas时的缩放大小</p></blockquote><h3 id="切片-slice" tabindex="-1">切片(slice) <a class="header-anchor" href="#切片-slice" aria-label="Permalink to “切片(slice)”">​</a></h3><blockquote><p>drawImage(image, sx, sy, sWidth, sHeight, dx,dy,dWidth, dHeight) 前四个定义图片源的切片位置和大小,后4个定义切片的目标显示位置和大小</p></blockquote><h2 id="状态的保存和恢复" tabindex="-1">状态的保存和恢复 <a class="header-anchor" href="#状态的保存和恢复" aria-label="Permalink to “状态的保存和恢复”">​</a></h2><ol><li>save: canvas状态存储在栈中, 每当save方法被调用后,当前的状态就会被推送到栈中保存 <blockquote><ol><li>当前应用的变形(即移动, 旋转,缩放)</li><li>storkeStyle\\fillStyle\\globalAlpha\\lineWidth\\lineCap\\lineJoin\\miterLimit\\shadowOffsetX\\shadowOffsetY\\shadowBlur\\shadowColor\\globalCompositeOpeeration</li><li>当前的裁剪路径(clipping path);</li></ol></blockquote></li><li>restore: 每一次调用restore方法,上一个保存的状态就从栈中弹出</li></ol><h2 id="变形" tabindex="-1">变形 <a class="header-anchor" href="#变形" aria-label="Permalink to “变形”">​</a></h2><ol><li>translate(x, y): 平移</li><li>rotate(angle): 先转角度(angle),它是顺时针移动,以弧度为单位值, 顺时针移动45度 为 Math.PI / 180 * 45</li><li>scale(x,y): 必须为正值,比1大放大,比1小缩小</li><li>transform(a,b,c,d,e,f) 变形矩阵</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>[</span></span>
<span class="line"><span>  [a,c,e],</span></span>
<span class="line"><span>  [b,d,f],</span></span>
<span class="line"><span>  [0,0,1]</span></span>
<span class="line"><span>]</span></span></code></pre></div><h2 id="合成" tabindex="-1">合成 <a class="header-anchor" href="#合成" aria-label="Permalink to “合成”">​</a></h2><ol><li>默认设置: 新图像会覆盖在原有图像上</li><li>source-in: 仅仅会出现新图像与原来图像重叠的部分,其他区域都变成透明的(其他的老图像区域也会透明)</li><li>source-out: 仅仅显示新图像与老图像没有重叠的部分,其余部分全部透明(老图像也不显示)</li><li>source-stop: 新图像仅仅显示与老图像重叠区域.老图像仍然可以显示</li><li>destination-over: 新图像会在老图像的下面</li><li>destination-in: 仅仅新老图像重叠部分的老图像被显示, 其他区域全部透明</li><li>destination-out: 仅仅老图像与新图像没有重叠的部分.注意显示的是老图像的部分区域</li><li>destination-stop: 老图像仅仅显示重叠部分,新图像会显示在老图像的下面</li><li>lighter: 新老图像都显示,但是重叠区域的颜色做加处理</li><li>darken: 保留重叠部分最黑的像素.(每个颜色位进行比较,得到最小的)</li><li>lighten: 保证重叠部分最大的量的像素值(每个颜色位进行比较,得到最大的)</li><li>xor: 重叠部分会变成透明</li><li>copy: 只有新图像会被保留,其余的全部被清除(边透明)</li></ol><h2 id="裁剪路径" tabindex="-1">裁剪路径 <a class="header-anchor" href="#裁剪路径" aria-label="Permalink to “裁剪路径”">​</a></h2><p>clip() 把已经创建的路径转换成裁剪路径.裁剪路径的作用是遮罩.只显示裁剪路径内的区域,裁剪路径外的区域会被隐藏. 注意: clip() 只能遮罩在这个方法调用之后绘制的图像,如果是clip()方法调用之前绘制的图像,则无法实现遮罩</p><h2 id="动画" tabindex="-1">动画 <a class="header-anchor" href="#动画" aria-label="Permalink to “动画”">​</a></h2><h3 id="动画的基本步骤" tabindex="-1">动画的基本步骤 <a class="header-anchor" href="#动画的基本步骤" aria-label="Permalink to “动画的基本步骤”">​</a></h3><ol><li>清空canvas 再绘制每一帧动画之前,需要清空所有.清空所有最简单的做法就是clearReact()方法</li><li>保存canvas 状态 如果在绘制过程中会更改canvas的状态(颜色、移动了坐标原点等),又在绘制每一帧时都是原始状态的话,则最好保存下canvas的状态</li><li>绘制动画图形这一步才是真正绘制动画帧</li><li>绘制canvas状态如果你保存了canvas状态,则应该在绘制完成一帧之后恢复canvas状态</li></ol><h3 id="控制动画" tabindex="-1">控制动画 <a class="header-anchor" href="#控制动画" aria-label="Permalink to “控制动画”">​</a></h3><ol><li>setInterval()</li><li>setTimeout()</li><li>requestAnimationFrame()</li></ol>`,48)]))}const b=i(n,[["render",h]]);export{g as __pageData,b as default};
