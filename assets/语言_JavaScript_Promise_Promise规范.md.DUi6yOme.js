import{_ as i,c as l,o as a,a7 as r}from"./chunks/framework.t6yJIVLk.js";const c=JSON.parse('{"title":"Promise规范","description":"","frontmatter":{"title":"Promise规范","tags":["js","Promise"],"categories":["技术文档","前端","js"],"date":"2020-08-19T22:32:07.000Z"},"headers":[],"relativePath":"语言/JavaScript/Promise/Promise规范.md","filePath":"语言/JavaScript/Promise/Promise规范.md","lastUpdated":1750738239000}'),s={name:"语言/JavaScript/Promise/Promise规范.md"};function o(t,e,n,d,h,p){return a(),l("div",null,e[0]||(e[0]=[r('<h1 id="promise-a-规范" tabindex="-1">Promise A+ 规范 <a class="header-anchor" href="#promise-a-规范" aria-label="Permalink to “Promise A+ 规范”">​</a></h1><h2 id="术语" tabindex="-1">术语 <a class="header-anchor" href="#术语" aria-label="Permalink to “术语”">​</a></h2><table tabindex="0"><thead><tr><th>术语</th><th>描述</th></tr></thead><tbody><tr><td>Promise</td><td>promise是一个拥有then方法的对象和函数</td></tr><tr><td>thenable</td><td>是一个定义了then方法的对象和函数,</td></tr><tr><td>value(值)</td><td>指任何JavaScript的合法指(包括 undefined、thenable、promise)</td></tr><tr><td>expection</td><td>是使用throw语句抛出的值</td></tr><tr><td>reason(拒因)</td><td>表示一个promise的拒绝原因</td></tr></tbody></table><h2 id="promise的状态" tabindex="-1">Promise的状态 <a class="header-anchor" href="#promise的状态" aria-label="Permalink to “Promise的状态”">​</a></h2><p>一个Promise当前状态必须为以下三种状态中的一种: 等待态(Pending)、执行态(FulFilled)、拒绝态(Rejected)</p><h3 id="等待态-pending" tabindex="-1">等待态(Pending) <a class="header-anchor" href="#等待态-pending" aria-label="Permalink to “等待态(Pending)”">​</a></h3><p>处于等待态时,Promise需要满足一下条件:</p><ul><li>可以迁移至执行态或拒绝态</li></ul><h3 id="执行态-fulfilled" tabindex="-1">执行态(Fulfilled) <a class="header-anchor" href="#执行态-fulfilled" aria-label="Permalink to “执行态(Fulfilled)”">​</a></h3><p>处于执行态时,Promise需要满足一下条件:</p><ul><li>不能迁移至其他任何状态</li><li>必须拥有一个不可变的终值</li></ul><h3 id="拒绝态-rejected" tabindex="-1">拒绝态(Rejected) <a class="header-anchor" href="#拒绝态-rejected" aria-label="Permalink to “拒绝态(Rejected)”">​</a></h3><p>处于拒绝态时,promise需要满足一下条件:</p><ul><li>不能迁移至其他任何状态</li><li>必须拥有一个不可变拒因</li></ul><h2 id="then-方法" tabindex="-1">Then 方法 <a class="header-anchor" href="#then-方法" aria-label="Permalink to “Then 方法”">​</a></h2><p>一个 promise 必须提供一个 then 方法以访问其当前值\\终值\\拒因</p><p>promise 的 then 方法接受两个参数</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">promise.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(onFulfilled, onRejected)</span></span></code></pre></div><h3 id="参数可选" tabindex="-1">参数可选 <a class="header-anchor" href="#参数可选" aria-label="Permalink to “参数可选”">​</a></h3><p><code>onFulfilled</code>和<code>onRejected</code>都是可选参数.</p><ul><li>如果 onFulFilled 不是函数,其必须被忽略</li><li>如果 onRejected 不是函数,其必须被忽略</li></ul><h3 id="onfulfilled-特征" tabindex="-1">onFulFilled 特征 <a class="header-anchor" href="#onfulfilled-特征" aria-label="Permalink to “onFulFilled 特征”">​</a></h3><p>如果 onFulFilled 是函数:</p><ul><li>当 promise 执行结束后其必须被调用,其第一个参数为 promise 的终值</li><li>当 promise 执行结束前其不可被调用</li><li>其调用次数不可超过一次</li></ul><h3 id="onrejected-特征" tabindex="-1">onRejected 特征 <a class="header-anchor" href="#onrejected-特征" aria-label="Permalink to “onRejected 特征”">​</a></h3><p>如果 onRejected 是函数</p><ul><li>当 promise 被拒绝执行后其必须被调用,其第一个参数为 promise 的拒因</li><li>在 promise 被拒绝执行前其不可调用</li><li>其调用次数不可超过一次</li></ul><h3 id="调用时机" tabindex="-1">调用时机 <a class="header-anchor" href="#调用时机" aria-label="Permalink to “调用时机”">​</a></h3><p>onFulFilled 和 onRejected 只有在执行环境堆栈仅包含平台代码的时候才能被调用</p><h3 id="调用要求" tabindex="-1">调用要求 <a class="header-anchor" href="#调用要求" aria-label="Permalink to “调用要求”">​</a></h3><p>onFulFilled 和 onRejected 必须被作为函数调用(即没有 this 值)</p><h3 id="多次调用" tabindex="-1">多次调用 <a class="header-anchor" href="#多次调用" aria-label="Permalink to “多次调用”">​</a></h3><p>then 方法可以被同一个 promise 调用多次</p><ul><li>当 promise 成功执行时,所有 onFulfilled 需要按照其注册顺序依次回调</li><li>当 promise 被拒绝执行时,所有 onRejected 需要按照其注册顺序依次回调</li></ul><h3 id="返回" tabindex="-1">返回 <a class="header-anchor" href="#返回" aria-label="Permalink to “返回”">​</a></h3><p>then 方法必须返回一个 promise 对象</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">promise2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promise1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(onFulfilled,onRejected);</span></span></code></pre></div><ul><li>如果 onFulFilled 或者 onRejected 返回一个值 x,则运行下面 Promise 解决过程 <code>[[Resolve]](promise2, x)</code></li><li>如果 onFulFilled 或者 onRejected 抛出一个异常 e,则 promise2 必须拒绝执行,并返回拒因 e</li><li>如果 onFulFilled 不是函数且 promise1 成功执行,promise2 必须成功执行并返回相同的值</li><li>如果 onRejected 不是函数且 promise1 拒绝执行, promise2 必须拒绝执行并返回相同的拒因</li></ul><h2 id="promise-解决过程" tabindex="-1">Promise 解决过程 <a class="header-anchor" href="#promise-解决过程" aria-label="Permalink to “Promise 解决过程”">​</a></h2><p>Promise 解决过程是一个抽象的操作, 其需要输入一个 promise 和一个值,我们表示<code>[[Resolve]](promise, x)</code>,如果 x 有 then 方法且看上去想一个 Promise, 解决程序即尝试使 promise 接受 x 的状态;否则其用 x 的值来执行 promise</p><p>这种 thenable 的特性使得 Promise 的实现更具通用性: 只要其暴露出一个遵循 Promise/A+协议的 then 方法即可; 这同时也使遵循 Promise/A+ 规范的实现与那些不太规范但可用的实现能良好共存</p><p>运行<code>[[Resolve]](promise, x)</code>遵循以下步骤:</p><h3 id="x-与-promise-相等" tabindex="-1">x 与 promise 相等 <a class="header-anchor" href="#x-与-promise-相等" aria-label="Permalink to “x 与 promise 相等”">​</a></h3><p>如果 promise 和 x 指向同一对象,以 TypeError 为拒因拒绝执行 promise</p><h3 id="x-为-promise" tabindex="-1">x 为 Promise <a class="header-anchor" href="#x-为-promise" aria-label="Permalink to “x 为 Promise”">​</a></h3><p>如果 x 为 Promise,则使 promise 接受 x 的状态</p><ul><li>如果 x 处于等待态, promise 需要保持为等待态直至 x 被执行或拒绝</li><li>如果 x 处于执行态, 用同样的值执行 promise</li><li>如果 x 处于拒绝态, 用同样的拒因拒绝 promise</li></ul><h3 id="x-为对象或函数" tabindex="-1">x 为对象或函数 <a class="header-anchor" href="#x-为对象或函数" aria-label="Permalink to “x 为对象或函数”">​</a></h3><p>如果 x 为对象或者函数:</p><ul><li>把 x.then 赋值给 then</li><li>如果取 x.then 的值时抛出错误 e, 则以 e 为拒因拒绝 promise</li><li>如果 then 是函数, 将 x 作为函数的作用域 this 调用之. 传递两个回调函数作为参数,第一个参数叫做 resolvePromise, 第二个参数叫做 rejectPromise <ol><li>如果 resolvePromise 以值 y 为参数被调用,则运行<code>[[Resolve]](promise, y)</code></li><li>如果 rejectPromise 以拒因 r 作为参数被调用, 则以拒因 r 拒绝 promise</li><li>如果 resolvePromise 和 rejectPromise 均被调用,或者被同一参数调用了多次,则优先采用首次调用并忽略剩下的调用</li><li>如果调用 then 放大抛出异常 e: <ul><li>如果 resolvePromise 或 rejectPromise 已经被调用,则忽略之</li><li>否则以 e 为拒因拒绝 promise</li></ul></li><li>如果 then 不是函数,以 x 为参数执行 promise</li></ol></li><li>如果 x 不为对象或者函数,以 x 为参数执行 promise</li></ul><p>如果-个 promise 被一个循环的 thenable 链中的对象解决,而<code>[[Resolve]](promise, thenable)</code>的递归性质又使得其被再次调用,根据上述算法将会陷入无限递归之中.算法虽不强制要求,但也鼓励实施者检测这样的递归存在, 若检测到存在则以一个可识别的 TypeError 为拒因来拒绝 promise</p><h1 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to “参考资料”">​</a></h1><ol><li><a href="https://promisesaplus.com/" target="_blank" rel="noreferrer">Promise/A+规范 英文原版</a></li><li><a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noreferrer">Promise/A+规范 中文版本</a></li><li><a href="https://sobird.me/promise-getstarted-note.htm" target="_blank" rel="noreferrer">Promise 实现</a></li></ol>',53)]))}const b=i(s,[["render",o]]);export{c as __pageData,b as default};
