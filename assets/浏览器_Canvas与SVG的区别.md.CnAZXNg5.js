import{_ as o,c as n,o as s,a7 as r}from"./chunks/framework.t6yJIVLk.js";const p=JSON.parse('{"title":"Canvas 与 SVG 的区别","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/Canvas与SVG的区别.md","filePath":"浏览器/Canvas与SVG的区别.md","lastUpdated":1751079736000}'),l={name:"浏览器/Canvas与SVG的区别.md"};function g(i,t,a,e,c,d){return s(),n("div",null,t[0]||(t[0]=[r('<h1 id="canvas-与-svg-的区别" tabindex="-1">Canvas 与 SVG 的区别 <a class="header-anchor" href="#canvas-与-svg-的区别" aria-label="Permalink to “Canvas 与 SVG 的区别”">​</a></h1><p>Canvas 和 SVG 都是用于在网页上绘制图形的强大技术，但它们在工作原理、适用场景和特性上有<strong>本质区别</strong>。以下是它们的主要区别：</p><ol><li><p><strong>图形类型（核心区别）</strong></p><ul><li><strong>SVG (Scalable Vector Graphics - 可缩放矢量图形):</strong><ul><li>基于<strong>矢量</strong>。图形由数学公式定义的<strong>点、线、路径、形状（矩形、圆形等）、文本</strong>等元素组成。</li><li>图形是<strong>对象</strong>，是文档对象模型的一部分。</li><li>无限缩放不失真（因为是数学描述的）。</li></ul></li><li><strong>Canvas:</strong><ul><li>基于<strong>位图</strong>或<strong>光栅</strong>。它本质上是一个<strong>像素网格</strong>。</li><li>你通过 JavaScript API 在画布上绘制像素。绘制完成后，Canvas 不保留绘制的形状信息，只保留最终的像素数据。</li><li>放大时会出现像素化（锯齿）。</li></ul></li></ul></li><li><p><strong>DOM 结构</strong></p><ul><li><strong>SVG:</strong> SVG 元素是<strong>DOM 的一部分</strong>。每个图形（如 <code>&lt;circle&gt;</code>, <code>&lt;rect&gt;</code>, <code>&lt;path&gt;</code>）都是一个独立的 DOM 节点。你可以像操作其他 HTML 元素一样使用 JavaScript 和 CSS 来操作它们（添加事件、修改样式、动画）。</li><li><strong>Canvas:</strong> Canvas 本身是一个 HTML 元素 (<code>&lt;canvas&gt;</code>)，但它内部绘制的图形<strong>不是 DOM 的一部分</strong>。你无法直接通过 DOM 访问或操作画布上绘制的单个圆形或矩形。你只能操作 <code>&lt;canvas&gt;</code> 元素本身。</li></ul></li><li><p><strong>事件处理</strong></p><ul><li><strong>SVG:</strong> 因为每个图形元素都是 DOM 节点，你可以直接给它们添加事件监听器（如 <code>onclick</code>, <code>onmouseover</code>），实现<strong>精细的交互</strong>（点击一个特定图形触发动作）。</li><li><strong>Canvas:</strong> 只能给整个 <code>&lt;canvas&gt;</code> 元素添加事件监听器。要实现画布上特定区域的交互（比如点击一个绘制的按钮），你需要<strong>手动进行数学计算</strong>（判断鼠标坐标是否落在你绘制的某个形状区域内），这要复杂得多。</li></ul></li><li><p><strong>性能</strong></p><ul><li><strong>SVG:</strong> 当图形数量<strong>非常多</strong>（成千上万）或需要<strong>频繁重绘</strong>（如复杂动画的每一帧）时，性能会下降，因为操作大量 DOM 节点开销较大。</li><li><strong>Canvas:</strong> 对于<strong>大量对象</strong>和<strong>高频重绘</strong>（如游戏、复杂的动态数据可视化、实时图表更新）的场景性能<strong>更好</strong>。因为它直接操作像素，避免了 DOM 操作的开销。尤其是在使用 WebGL 进行硬件加速时，性能优势巨大。</li></ul></li><li><p><strong>API 与绘制方式</strong></p><ul><li><strong>SVG:</strong> 使用 <strong>声明式</strong> XML 语法定义图形（可以直接写在 HTML 里，也可以用 JS 创建元素）。也可以通过 JS 操作 DOM 来修改图形。</li><li><strong>Canvas:</strong> 使用 <strong>命令式</strong> JavaScript API (<code>getContext(&#39;2d&#39;)</code> 或 <code>getContext(&#39;webgl&#39;)</code>)。你需要编写 JS 代码来“命令”画布绘制线条、填充颜色、绘制文本等。绘制完成后，图形信息丢失，要修改就得重绘（部分或全部）。</li></ul></li><li><p><strong>文件大小与可压缩性</strong></p><ul><li><strong>SVG:</strong> 对于由简单几何形状组成的图形（图标、徽标、图表），文件通常<strong>非常小</strong>（因为是文本/XML）。文本压缩效果好。对于包含大量路径数据的复杂图像（如详细地图），文件可能变大。</li><li><strong>Canvas:</strong> 生成的图像是像素数据。最终文件大小取决于画布的分辨率和复杂度。需要导出为位图格式（PNG, JPG）才能在网页中使用，这些格式的大小通常比同等视觉复杂度的 SVG 大（尤其是简单图形），但压缩算法成熟。</li></ul></li><li><p><strong>CSS 样式支持</strong></p><ul><li><strong>SVG:</strong> 可以很好地使用 <strong>CSS</strong> 来设置图形的样式（填充色、描边、透明度、滤镜、动画等），样式与内容分离，易于维护和主题化。</li><li><strong>Canvas:</strong> 所有样式都必须在 JavaScript 绘制代码中<strong>显式设置</strong>（使用 Canvas API 的方法如 <code>fillStyle</code>, <code>strokeStyle</code>, <code>lineWidth</code>）。不能直接使用 CSS 来设置画布上绘制的图形样式。</li></ul></li><li><p><strong>搜索引擎优化与可访问性</strong></p><ul><li><strong>SVG:</strong> 文本内容是<strong>真实文本</strong>，可以被搜索引擎索引，也便于屏幕阅读器读取（需配合适当的 ARIA 属性或 <code>&lt;title&gt;</code>/<code>&lt;desc&gt;</code> 元素），<strong>可访问性更好</strong>。</li><li><strong>Canvas:</strong> 画布上的文本是<strong>绘制出来的像素</strong>，对于搜索引擎和屏幕阅读器来说是不可见的（除非提供额外的替代文本或使用 <code>&lt;canvas&gt;</code> 的 <code>aria-label</code> 等属性描述整个画布内容），<strong>可访问性较差</strong>。</li></ul></li><li><p><strong>响应式/分辨率无关性</strong></p><ul><li><strong>SVG:</strong> 天生是<strong>分辨率无关</strong>的。在任何屏幕尺寸或缩放级别下都能完美清晰显示。</li><li><strong>Canvas:</strong> 是固定分辨率的位图。在高 DPI（Retina）屏幕上需要处理<strong>像素比</strong>缩放，否则会模糊。需要通过 JS 动态调整画布尺寸或使用 <code>window.devicePixelRatio</code> 来适配高清屏。</li></ul></li></ol><p><strong>总结：如何选择？</strong></p><ul><li><strong>选择 SVG 当：</strong><ul><li>你需要<strong>可缩放、不失真</strong>的图形（图标、徽标、简单插图）。</li><li>你需要<strong>精细的交互</strong>（图形元素单独响应事件）。</li><li>图形相对<strong>静态</strong>或只有简单动画。</li><li>图形数量<strong>不是极其庞大</strong>。</li><li>需要良好的<strong>SEO 和可访问性</strong>（包含文本内容时）。</li><li>想用 <strong>CSS 控制样式和动画</strong>。</li><li>需要直接操作图形元素（通过 DOM）。</li></ul></li><li><strong>选择 Canvas 当：</strong><ul><li>你需要处理<strong>大量图形对象</strong>（粒子系统、复杂游戏场景）。</li><li>需要<strong>高性能的实时渲染和动画</strong>（游戏、动态数据可视化）。</li><li>进行<strong>像素级操作</strong>（图像处理、滤镜）。</li><li>使用 <strong>WebGL 进行 3D 渲染或高级 2D 图形</strong>。</li><li>图形内容<strong>频繁变化</strong>（每一帧都需要重绘）。</li><li>不介意手动处理交互或不需要精细的逐元素交互。</li><li>可以接受位图缩放可能带来的模糊（或愿意处理高清屏适配）。</li></ul></li></ul><p><strong>关键记忆点：</strong></p><ul><li><strong>SVG = 矢量 + DOM 对象 + 可交互 + 可缩放 + CSS 友好</strong></li><li><strong>Canvas = 位图 + 像素操作 + 高性能重绘 + WebGL + 复杂交互需手动计算</strong></li></ul><p>有时，它们也可以结合使用，例如在 Canvas 中绘制一个 SVG 图像，或者用 SVG 作为界面元素覆盖在 Canvas 游戏之上，以利用各自的优势。</p>',8)]))}const v=o(l,[["render",g]]);export{p as __pageData,v as default};
