import{_ as i,c as a,o as t,a7 as l}from"./chunks/framework.CegclTe-.js";const g=JSON.parse('{"title":"什么是JSONP","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/什么是JsonP.md","filePath":"浏览器/什么是JsonP.md","lastUpdated":1751078101000}'),n={name:"浏览器/什么是JsonP.md"};function e(r,s,h,o,p,k){return t(),a("div",null,s[0]||(s[0]=[l(`<h1 id="什么是jsonp" tabindex="-1">什么是JSONP <a class="header-anchor" href="#什么是jsonp" aria-label="Permalink to “什么是JSONP”">​</a></h1><p><strong>JSONP（JSON with Padding）</strong> 是一种解决浏览器<strong>跨域数据请求限制</strong>的变通技术（非官方标准）。它的核心思想是：<strong>利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性，动态创建 script 标签来加载跨域数据。</strong></p><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to “工作原理”">​</a></h2><ol><li><p><strong>前端定义回调函数：</strong></p><ul><li>在你的网页中，定义一个 JavaScript 函数（例如 <code>handleResponse</code>）。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在这里处理从跨域服务器返回的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Received data:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>动态创建 Script 标签：</strong></p><ul><li>使用 JavaScript 动态创建一个 <code>&lt;script&gt;</code> 标签。</li><li>将它的 <code>src</code> 属性设置为<strong>目标跨域 API 的 URL</strong>。</li><li>关键点：<strong>在 URL 中指定一个查询参数（通常是 <code>callback</code>）来告诉服务器你定义的回调函数名是什么。</strong></li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> script</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://api.example.com/data?callback=handleResponse&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意 callback 参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span></code></pre></div></li><li><p><strong>服务器响应特殊格式：</strong></p><ul><li>跨域服务器收到请求后，识别出 <code>callback</code> 参数的值（这里是 <code>handleResponse</code>）。</li><li>服务器<strong>不返回纯 JSON</strong>，而是返回一段<strong>可执行的 JavaScript 代码</strong>。</li><li>这段代码的内容是：<strong>调用前端定义的那个回调函数，并把真正的 JSON 数据作为参数传递进去。</strong></li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;city&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New York&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务器实际返回的内容</span></span></code></pre></div></li><li><p><strong>前端执行响应并处理数据：</strong></p><ul><li>浏览器加载并执行这个 <code>&lt;script&gt;</code> 标签返回的 JavaScript 代码。</li><li>这段代码执行时，就会调用你之前定义的 <code>handleResponse</code> 函数。</li><li><code>handleResponse</code> 函数接收到服务器返回的 JSON 数据（现在作为函数的参数 <code>data</code>），你就可以在自己的页面里自由使用这些数据了。</li></ul></li></ol><h2 id="关键特点" tabindex="-1">关键特点 <a class="header-anchor" href="#关键特点" aria-label="Permalink to “关键特点”">​</a></h2><ul><li><strong>绕过同源策略：</strong> 核心是利用 <code>&lt;script&gt;</code> 标签可以跨域加载资源的特性。</li><li><strong>基于回调 (Callback)：</strong> 必须定义一个全局函数来处理返回的数据。</li><li><strong>服务器需支持：</strong> 目标服务器必须设计成能够识别 <code>callback</code> 参数并返回包裹在函数调用中的 JSONP 响应。</li><li><strong>仅支持 GET 请求：</strong> 因为本质是加载一个脚本资源，所以只能使用 HTTP GET 方法，无法使用 POST、PUT、DELETE 等。</li></ul><h2 id="为什么需要-jsonp-历史背景" tabindex="-1">为什么需要 JSONP（历史背景） <a class="header-anchor" href="#为什么需要-jsonp-历史背景" aria-label="Permalink to “为什么需要 JSONP（历史背景）”">​</a></h2><p>在 <strong>CORS（Cross-Origin Resource Sharing）</strong> 成为标准并被广泛支持之前，浏览器严格禁止 XMLHttpRequest（XHR）或 Fetch API 向不同源（协议、域名、端口任一不同）的服务器发起请求。JSONP 提供了一种巧妙（但非正式）的变通方案来解决这个限制。</p><h2 id="jsonp-的缺点与风险" tabindex="-1">JSONP 的缺点与风险 <a class="header-anchor" href="#jsonp-的缺点与风险" aria-label="Permalink to “JSONP 的缺点与风险”">​</a></h2><ol><li><strong>仅支持 GET：</strong> 无法执行 POST 等操作，限制了使用场景。</li><li><strong>安全性风险：</strong><ul><li><strong>XSS（跨站脚本攻击）风险：</strong> 你完全信任服务器返回的脚本代码。如果服务器被黑或者 API 本身恶意，它返回的脚本可以执行任何操作（窃取 Cookie、篡改页面等）。</li><li><strong>缺乏错误处理：</strong> 很难像 XHR/Fetch 那样可靠地检测网络错误或服务器错误（如 404, 500）。如果加载失败，只能通过超时机制猜测。</li><li><strong>CSRF（跨站请求伪造）风险：</strong> 虽然 GET 请求本身也可能导致 CSRF，但 JSONP 更容易被滥用，因为它天然就是跨域的 GET 请求。</li></ul></li><li><strong>回调函数管理：</strong> 需要管理全局命名空间中的回调函数名，多个并发请求时容易冲突（尽管可以通过生成唯一函数名解决）。</li><li><strong>调试困难：</strong> 错误信息不如 XHR/Fetch 清晰。</li></ol><h2 id="现代替代方案-cors" tabindex="-1">现代替代方案：CORS <a class="header-anchor" href="#现代替代方案-cors" aria-label="Permalink to “现代替代方案：CORS”">​</a></h2><p><strong>CORS（跨域资源共享）</strong> 是 W3C 标准，是解决跨域问题的<strong>首选、安全和官方的方式</strong>。它通过在 HTTP 请求和响应中添加特定的头部（如 <code>Origin</code>, <code>Access-Control-Allow-Origin</code>）来让浏览器和服务器协商是否允许跨域访问。现代浏览器广泛支持 CORS。</p><ul><li><strong>支持所有 HTTP 方法（GET, POST, PUT, DELETE 等）。</strong></li><li><strong>更精细的控制（允许的域名、方法、头信息等）。</strong></li><li><strong>内置安全性机制。</strong></li><li><strong>更好的错误处理。</strong></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><ul><li><strong>JSONP 是什么？</strong> 一种利用 <code>&lt;script&gt;</code> 标签进行跨域 GET 请求的“Hack”技术。</li><li><strong>核心原理：</strong> 前端定义回调函数，通过 script.src 告诉服务器函数名；服务器返回调用该函数并包裹 JSON 数据的 JS 代码；浏览器执行代码触发回调处理数据。</li><li><strong>主要缺点：</strong> 仅 GET、严重安全隐患（XSS）、错误处理差、调试难。</li><li><strong>现代方案：</strong> <strong>优先使用 CORS</strong>。只有在必须支持非常老的浏览器或访问无法配置 CORS 的旧服务时，才考虑 JSONP（并充分意识到其风险）。</li></ul><p>简单来说，JSONP 是早期解决跨域问题的一个巧妙但存在安全隐患的变通方法，<strong>现代 Web 开发中应首选 CORS。</strong></p>`,16)]))}const c=i(n,[["render",e]]);export{g as __pageData,c as default};
